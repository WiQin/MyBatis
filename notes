一 mybatis入门
	1.1 mybatis是什么
		MyBatis是一个简化和实现了 Java 数据持久化层(persistence layer)的开源框架，它抽象了大量的JDBC冗余代码，并提供了一个简单易用的API和数据库交互。
		MyBatis的前身是iBATIS，iBATIS于2002年由ClintonBegin创建。MyBatis3是iBATIS的全新设计，支持注解和Mapper。
		MyBatis流行的主要原因在于它的简单性和易使用性。在Java应用程序中，数据持久化层涉及到的工作有：将从数据库查询到的数据生成所需要的Java对象；将Java对象中的数据通SQL持久化到数据库中。
		MyBatis通过抽象底层的JDBC代码，自动化SQL结果集产生Java对象、Java对象的数据持久化数据库中的过程使得对SQL的使用变得容易。

	1.2 Git 是一个免费开源的分布式版本控制系统，被用于高速有效地处理大大小小项目中所有文件,在软件开发中使用的其他版本控制软件类似与SVN、VSS、CVS等等.

	1.3 作为一个分布式的版本控制系统，在Git中并不存在主库这样的概念，每一份复制出的库都可以独立使用，任何两个库之间的不一致之处都可以进行合并。github以托管各种git库，并提供一个web界面，可以说是一款易于使用的git图形客户端。我们熟知的spring、struts、Hibernate等框架的源代码在github上面都可以找到其源代码

	1.4 iBATIS一词来源于internet和abatis的组合，是一个在2002年发起的开放源代码项目。于2010年6月16号被谷歌托管，改名为MyBatis。
		ibatis的官网 http://ibatis.apache.org/ 进去官网会看到下面提示:
		apache ibatis is retired at the apache software foundation (2010/06/16)
		the original project team has moved to mybatis hosted at google code. see http://www.mybatis.org/ for more.
		然而http://www.mybatis.org/这个地址一直处于打不开状态...
		但是我们最终是可以在github中找到mybatis的相关下载的:
		mybatis在github中的地址
		https://github.com/mybatis/mybatis-3
		最新版本的mybatis的下载地址
		https://github.com/mybatis/mybatis-3/releases
		doc文档
		http://www.mybatis.org/mybatis-3/

	1.5 当前有很多Java实现的持久化框架，而MyBatis流行起来有以下原因：
		1.5.1 它消除了大量的JDBC冗余代码
			Java通过JDBC的API来操作关系型数据库，但是JDBC是一个非常底层的API,我们需要书写大量的代码来完成对数据库的操作。例如一个插入操作(参考之前学习JDBC时候的代码实例)
			但是使用mybatis来完成相同的插入操作要简单方便灵活的多:
			第一步:在SQLMapper映射配置文件中配置SQL语句，假定为StudentMapper.xml
			<insert id="insertStudent" parameterType="Student">
				INSERT INTO STUDENTS(ID,NAME,EMAIL)
				VALUES(#{id},#{name},#{email})
			</insert>
			第二步:创建一个StudentMapper接口
			public interface StudentMapper{
				void insertStudent(Student student);
			}
			第三步:编写java代码完成插入操作:
			SqlSession session = getSqlSessionFactory().openSession();
			StudentMapper mapper = session.getMapper(StudentMapper.class);
			mapper.insertStudent(student);

			特别之处的是，MyBatis还提供了其他的一些特性来简化持久化逻辑的实现
			它支持复杂的SQL结果集数据映射到嵌套的对象结构
			它支持一对一和一对多的结果集和Java对象的映射
			它支持根据输入的数据构建动态的SQL语句
		1.5.2 它有低的学习曲线
			MyBatis能够流行的首要原因之一在于它学习和使用起来非常简单，它取决于你Java和 SQL方面的知识。如果开发人员很熟悉Java和SQL，他们会发现MyBatis入门非常简单。
		1.5.3 它能很好地与传统数据库协同工作
			有时我们可能需要用不正规形式与传统数据库协同工作，使用成熟的ORM框架(例如大家熟知的Hibernate)有可能、但是很难跟传统数据库很好地协同工作，因为他们尝试将Java对象静态地映射到数据库的表上.而MyBatis是将查询的结果与Java对象映射起来，这使得MyBatis可以很好地与传统数据库协同工作。你可以根据面相对象的模型创建Java域对象，执行传统数据库的查询，然后将结果映射到对应的Java对象上。
		1.5.4 它可以接受SQL语句
			成熟的ORM框架鼓励使用实体对象和在其底层自动产生SQL语句。由于这种的SQL生成方式，我们有可能不能够利用到数据库的一些特有的特性。Hibernate允许执行本地SQL，但是这样会打破持久层和数据库独立的原则。MyBatis框架接受SQL语句，而不是将其对开发人员隐藏起来。由于MyBatis不会产生任何的SQL语句，所以开发人员就要准备SQL语句，这样就可以充分利用数据库特有的特性并且可以准备自定义的查询。另外，MyBatis 对存储过程也提供了支持。
		1.5.5 它提供了与Spring框架的集成支持
			MyBatis提供了与流行的依赖注入框架Spring的开包即用的集成支持，这将进一步简化MyBatis的使用
		1.5.6 它提供了与第三方缓存类库的集成支持
			MyBatis有内建的SqlSession级别的缓存机制，用于缓存Select语句查询出来的结果。除此之外，MyBatis提供了与多种第三方缓存类库的集成支持，如EHCache，OSCache，Hazelcast等。
		1.5.7 它引入了更好的性能
			性能问题是关乎软件应用成功与否的关键因素之一。为了达到更好的性能，需要考虑很多事情，而对很多应用而言，数据持久化层是整个系统性能的关键。MyBatis支持数据库连接池，消除了为每一个请求创建一个数据库连接的开销,MyBatis提供了内建的缓存机制，在SqlSession级别提供了对SQL查询结果的缓存。即:如果你调用了相同的select查询，MyBatis 会将放在缓存的结果返回，而不会去再查询数据库。MyBatis框架并没有大量地使用代理机制，因此对于其他的过度地使用代理的ORM框架而言，MyBatis可以获得更好的性能.

	1.6 mybatis的jar包
		mybatis的核心包只有一个mybatis-3.x.0.jar,另外还有一些【可选】的依赖包(日志、代理等所需要的),在下载的压缩包中可以找到.

	1.7 mybatis框架中一般需要俩种文件:
		第一种:mybatis的配置文件: mybatis-config.xml,其中包括数据库连接信息，类型别名等等
			特点:
				名字一般是固定的
				位置是src下面
			示例:
			<?xml version="1.0" encoding="utf-8"?>
			<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
			"http://mybatis.org/dtd/mybatis-3-config.dtd">
			<configuration>
			  <typeAliases>
				<typeAlias alias="Student" type="com.briup.bean.Student" />
			  </typeAliases>
			  <environments default="development">
				<environment id="development">
				  <transaction Manager type="JDBC" />
				   <dataSource type="POOLED">
					<!--
					<property name="driver" value="com.mysql.jdbc.Driver" />
					<property name="url" value="jdbc:mysql://localhost:3306/test" />
					-->
					<property name="driver" value="oracle.jdbc.driver.OracleDriver" />
					<property name="url" value="jdbc:oracle:thin:@127.0.0.1:1521:XE" />
					<property name="username" value="test" />
					<property name="password" value="test" />
				  </dataSource>
				</environment>
			  </environments>
			  <mappers>
				<mapper resource="com/briup/bean/StudentMapper.xml" />
			  </mappers>
			</configuration>


		第二种:mybatis的映射文件:XxxxxMapper.xml,这个xml文件中包括Xxxx类所对应的数据库表的各种增删改查sql语句
			特点:
				名字一般为XxxxMapper.xml,Xxxx是对应类的名字
				位置不固定,一般放到一个专门的package里面
			实例:
			<?xml version="1.0" encoding="utf-8"?>
			<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
			"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
			<mapper namespace="com.briup.bean.StudentMapper">
			  <resultMap type="Student" id="StudentResult">
				<id property="id" column="id" />
				<result property="name" column="name" />
				<result property="email" column="email" />
			  </resultMap>
			  <select id="findAllStudents" resultMap="StudentResult">
					SELECT * FROM STUDENTS
			  </select>
			  <select id="findStudentById" parameterType="int" resultType="Student">
				 SELECT ID AS STUDID, NAME, EMAIL
					 FROM STUDENTS WHERE ID=#{Id}
			  </select>
			  <insert id="insertStudent" parameterType="Student">
				 INSERT INTO STUDENTS(ID,NAME,EMAIL)
					 VALUES(#{id },#{name},#{email})
			  </insert>
			</mapper>

	1.8 mybatis中的映射接口XxxxMapper.java(对XxxxMapper.xml中的sql语句进行映射)
		mybatis中除了必须的jar包、各种xml配置文件之外,一般还需要有调用sql语句执行的接口XxxxMapper.java
		示例:
		public interface StudentMapper{
			List<Student> findAllStudents();
			Student findStudentById(Integer id);
			void insertStudent(Student student);
		}
		注意:接口中的方法的名字和XML文件定义的SQL映射语句的名称要相同
		同时我们不需要去实现该接口,因为mybatis中提供了相应的方式在运行期间动态生成该接口的实现类对象(动态代理技术,spring框架中会想些讲解动态代理).

	1.9 mybatis中的SqlSession接口和sqlSessionFactory接口
		SqlSession接口的实现类对象是mybatis中最重要的一个对象,我们可以使用该对象动态获得XxxxMapper.java接口的实现类对象,然后就可以调用到XxxxMapper.java接口中方法所映射的sql语句(在xml文件中配置的sql语句)。
		sqlSessionFactory接口的实现类对象是一个工厂对象,专门负责来产生SqlSession对象的
		例如:
		InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml");
		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
		SqlSession sqlSession = sqlSessionFactory.openSession();

		//第一种执行sql语句的方式  通过XxxxMapper接口的实现类对象来调用
		//动态获得XxxxMapper接口的实现类
		StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);
		studentMapper.insertStudent(new Student(1,"tom","123@.qq.com"));

		//第二种执行sql语句的方式  执行调用XxxxMapper.xml中写好的sql语句
		//也可以【不通过】Mapper接口执行映射的SQL
		//然而，使用 Mapper接口是最佳实践
		//sqlSession.selectOne("com.briup.bean.StudentMapper.findStudentById",1);

	1.10 编写一个简单的mybatis进行插入数据的实例
		1.10.1 数据库建表  dob=Date of Birth
			CREATE TABLE STUDENTS (
				stud_id number PRIMARY KEY,
				name varchar2(50) ,
				email varchar2(50) ,
				dob date
			);

		1.10.2 新建一个项目,创建好相应的package及class
			package com.briup.bean;
			import java.util.Date;
			public class Student {
				private Integer studId;
				private String name;
				private String email;
				private Date dob;
				get/set
			}

		1.10.3 项目中引入mybatis的核心包以及可选的依赖包
			必须的包  mybatis-3.3.0.jar    ojdbc14.jar
			可选的包  junit-4.7.jar             log4j-1.2.17.jar
		1.10.4 mybatis中的配置文件和映射文件分别引入到项目中
			src下面的mybatis-config.xml:
			<?xml version="1.0" encoding="UTF-8"?>
			<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
			"http://mybatis.org/dtd/mybatis-3-config.dtd">
			<configuration>
				<typeAliases>
					<typeAlias type="com.briup.bean.Student" alias="Student" />
				</typeAliases>

				<environments default="development">
					<environment id="development">
						<transactionManager type="JDBC"></transactionManager>
						<dataSource type="POOLED">
							<property name="driver" value="oracle.jdbc.driver.OracleDriver" />
							<property name="url" value="jdbc:oracle:thin:@127.0.0.1:1521:XE" />
							<property name="username" value="test" />
							<property name="password" value="test" />
						</dataSource>
					</environment>
				</environments>

				<mappers>
					<mapper resource="com/briup/mappers/StudentMapper.xml"/>
				</mappers>

			</configuration>



			com.briup.mappers包下面的StudentMapper.xml:

			<?xml version="1.0" encoding="UTF-8"?>
			<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
			"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
			<!-- com.briup.mappers.StudentMapper是我们定义接口的全限定名字 这样就可以使用接口调用映射的SQL语句了 这个名字一定要和接口对应上-->
			<mapper namespace="com.briup.mappers.StudentMapper">

				<resultMap type="Student" id="StudentResult">
					<id property="studId" column="stud_id" />
					<result property="name" column="name" />
					<result property="email" column="email" />
					<result property="dob" column="dob" />
				</resultMap>

				<select id="findAllStudents" resultMap="StudentResult">
					SELECT * FROM STUDENTS
				</select>

				<!-- 列名和属性名字不一致可以给查询的列起一个别名 -->
				<select id="findStudentById" parameterType="int" resultType="Student">
					SELECT STUD_ID AS STUDID,NAME,EMAIL,DOB
					FROM STUDENTS
					WHERE
					STUD_ID=#{id}
				</select>
				<insert id="insertStudent" parameterType="Student">
					INSERT INTO
					STUDENTS(STUD_ID,NAME,EMAIL,DOB)
					VALUES(#{studId},#{name},#{email},#{dob})
				</insert>
			</mapper>

		1.10.5 配置log4j.properties文件中的日志输出:
			位置src下面
			内容:
			log4j.rootLogger=DEBUG, stdout
			log4j.appender.stdout=org.apache.log4j.ConsoleAppender
			log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
			log4j.appender.stdout.layout.ConversionPattern=%d [%-5p] %c - %m%n
			#show sql
			log4j.logger.java.sql.ResultSet=INFO
			log4j.logger.org.apache=INFO
			log4j.logger.java.sql.Connection=DEBUG
			log4j.logger.java.sql.Statement=DEBUG
			log4j.logger.java.sql.PreparedStatement=DEBUG

		1.10.6 com.briup.mappers包下面新建一个接口StudentMapper.java,用来对应xml文件中的sql语句(映射),从而方便我们调用
			package com.briup.mappers;
			import java.util.List;
			import com.briup.bean.Student;

			//创建映射器Mapper接口StudentMapper
			//方法名和StudentMapper.xml中定义的SQL映射定义名相同
			//这个其实就是dao层接口(数据访问层,负责和数据库进行交互)
			public interface StudentMapper {
				List<Student> findAllStudents();
				Student findStudentById(Integer id);
				void insertStudent(Student student);
			}

		1.10.7 创建一个测试类StudentMapperTest.java
			package test;
			import java.io.InputStream;
			import java.util.Date;

			import org.apache.ibatis.io.Resources;
			import org.apache.ibatis.session.SqlSession;
			import org.apache.ibatis.session.SqlSessionFactory;
			import org.apache.ibatis.session.SqlSessionFactoryBuilder;
			import org.junit.Test;

			import com.briup.mappers.StudentMapper;
			import com.briup.bean.Student;

			public class StudentMapperTest {

				@Test
				public void test_insert(){

					try {
						InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml");
						SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
						SqlSession sqlSession = sqlSessionFactory.openSession();

						StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);
						Student s = new Student(1,"tom","123@briup.com",new Date());
						studentMapper.insertStudent(s);
						sqlSession.commit();
					} catch (Exception e) {
						e.printStackTrace();
					}

				}
			}

		1.10.8 运行成功后会在控制台中看到log4j日志输出的这个程序运行的相关信息

		1.10.9 对mybatis的一些基本封装
			每次读取配置文件,产生一个工厂对象SqlSessionFactory,然后再生成出SqlSession对象,这个过程虽然并不复杂,但是也都是一些重复的代码流程,所以我们可以对其进行一个简单的封装:
			package com.briup.utils;

			import java.io.IOException;
			import java.io.InputStream;

			import org.apache.ibatis.io.Resources;
			import org.apache.ibatis.session.SqlSession;
			import org.apache.ibatis.session.SqlSessionFactory;
			import org.apache.ibatis.session.SqlSessionFactoryBuilder;

			public class MyBatisSqlSessionFactory {
				private static SqlSessionFactory sqlSessionFactory;

				public static SqlSessionFactory getSqlSessionFactory(){
					if(sqlSessionFactory == null){
						InputStream inputStream = null;
						try {
							inputStream = Resources.getResourceAsStream("mybatis-config.xml");
							sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
						} catch (IOException e) {
							e.printStackTrace();
							throw new RuntimeException(e.getCause());
						}
					}
					return sqlSessionFactory;
				}

				public static SqlSession openSession() {
					return openSession(false);
				}
				public static SqlSession openSession(boolean autoCommit) {
					return getSqlSessionFactory().openSession(autoCommit);
				}

			}

			之后每次使用的时候只需要调用该类中的静态方法openSession即可
			上面的代码可简写为: //注意事务是自动提交还是手动提交
			MyBatisSqlSessionFactory.openSession().getMapper(StudentMapper.class).insertStudent(s);

			*******************************************************
			注意:xml文件中写的sql语句,最后面不要写分号,否则会报错误,ORA-00911: 无效字符
			*******************************************************

二 mybatis配置详解
	MyBatis最关键的组成部分是SqlSessionFactory，我们可以从中获取SqlSession， 并执行映射的SQL语句。SqlSessionFactory对象可以通过基于XML的配置信息或者JavaAPI创建。

	2.1 使用xml配置Mybatis
		构建SqlSessionFactory最常见的方式是基于XML配置。下面的 mybatis-config.xml展示了一个典型的MyBatis配置文件的样子:
		<?xml version="1.0" encoding="utf-8"?>
		<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
		"http://mybatis.org/dtd/mybatis-3-config.dtd">
		<configuration>
		  <properties resource="application.properties">
			<property name="username" value="db_user" />
			<property name="password" value="verysecurepwd" />
		  </properties>
		  <settings>
			<setting name="cacheEnabled" value="true" />
		  </settings>
		  <typeAliases>
			<typeAlias alias="Student" type="com.briup.bean.Student" />
			<package name="com.briup.bean" />
		  </typeAliases>
		  <typeHandlers>
			<typeHandler handlers="com.mybatis3.typehandlers.PhoneTypeHandler" />
			<package name="com.briup.typehandlers" />
		  </typeHandlers>
		  <environments default="development">
			<environment id="development">
			  <transactionManager type="JDBC" />
			  <dataSource type="POOLED">
				<property name="driver" value="${jdbc.driverClassName}" />
				<property name="url" value="${jdbc.url}" />
				<property name="username" value="${jdbc.username}" />
				<property name="password" value="${jdbc.password}" />
			  </dataSource>
			</environment>
			<environment id="production">
			  <transactionManager type="MANAGED" />
			  <dataSource type="JNDI">
				<property name="data_source" value="java:comp/jdbc/MyBatisDemoDS" />
			  </dataSource>
			</environment>
		  </environments>
		  <mappers>
			<mapper resource="com/briup/mappers/StudentMapper.xml" />
			<mapper url="file:///D:/mybatisdemo/mappers/StudentMapper.xml" />
			<mapper class="com.briup.mappers.StudentMapper" />
		  </mappers>
		</configuration>

		2.1.1 environments元素
		environments是配置mybatis当前工作的数据库环境的地方
		MyBatis可以支持配置多个dataSource环境，可以将应用部署到不同的环境上，如DEV(开发环境)，TEST（测试环境），QA（质量评估环境）,UAT(用户验收环境),PRODUCTION（生产环境），可以通过将默认environments值设置成想要的environment的id值。

		有时候，我们可能需要在相同的应用下使用多个数据库,比如我们可能有shoppingcart数据库来存储所有的订单明细；使用reports数据库存储订单明细的合计，用作报告。(也就是如果系统在运行期间如果有【切换数据库环境】的需求,mybatis中也可以很轻松的实现).
		如果你的应用需要连接多个数据库，你需要将每个数据库配置成独立的环境，并且为每一个数据库创建一个SqlSessionFactory
		例如:
		<environments default="shoppingcart">
		  <environment id="shoppingcart">
			<transactionManager type="MANAGED" />
			<dataSource type="JNDI">
			  <property name="data_source" value="java:comp/jdbc/ShoppingcartDS" />
			</dataSource>
		  </environment>
		  <environment id="reports">
			<transaction Managertype="MANAGED" />
			<dataSource type="JNDI">
			  <property name="data_source" value="java:comp/jdbc/ReportsDS" />
			</dataSource>
		  </environment>
		</environments>

		我们可以为以上每个环境创建一个SqlSessionFactory
		java代码:
		inputStream = Resources.getResourceAsStream("mybatis-config.xml");
		//默认的环境 default
		SqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);

		//统计明细的环境 cart
		SqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream, "shoppingcart");

		//统计报表的环境 report
		SqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream, "reports");

		注意:一个数据库环境对应一个SqlSessionFactory对象
		注意:对于environments,我们可以在其中配置多个environment子元素,同时还需要在environment中配置dataSource和transactionManager元素。


		2.1.2 dataSource元素
		dataSource表示的是数据源:至少会包括该连接数据库的四种信息
		<dataSource type="POOLED">
		  <property name="driver" value="${jdbc.driverClassName}" />
		  <property name="url" value="${jdbc.url}" />
		  <property name="username" value="${jdbc.username}" />
		  <property name="password" value="${jdbc.password}" />
		</dataSource>

		dataSource的类型type属性可以配置成其内置类型之一，如UNPOOLED，POOLED，JNDI。
		如果将类型设置成UNPOOLED，MyBatis会为每一个数据库操作创建一个新的连接，使用完了并关闭它，该方式适用于只有小规模数量并发用户的简单应用程序上。

		如果将属性设置成POOLED，MyBatis会创建一个数据库连接池，连接池中的一个连接将会被用作数据库操作(分配，管理，释放)。一旦数据库操作完成，MyBatis会将此连接返回给连接池。在开发或测试环境中，经常使用此种方式。连接：关键有限的昂贵资源
	
		如果将类型设置成JNDI(Java Naming and Directory Interface , Java命名和目录接口, 是SUN公司提供的一种标准的Java命名系统接口)，MyBatis从在应用服务器向配置好的JNDI数据源dataSource获取数据库连接。在生产环境中，优先考虑这种方式。


		2.1.3 transactionManager元素 :事务管理器
		MyBatis支持两种类型的事务管理器：JDBC 和 MANAGED.
		JDBC事务管理器的使用，是在【jdbc程序】负责管理数据库连接的生命周期（提交、回退等等）的时候。如果将TransactionManager 属性设置成JDBC，MyBatis内部将使用JdbcTransactionFactory类创建TransactionManager。例如，部署到ApacheTomcat的应用程序，需要应用程序自己管理事务。

		MANAGED 事务管理器的使用，是在【应用服务器】负责管理数据库连接生命周期的时候。如果将TransactionManager属性设置成MANAGED时，MyBatis内部使用ManagedTransactionFactory 类创建事务管理器TransactionManager。例如，当一个Java EE的应用程序部署在类似JBoss，WebLogic，GlassFish等应用服务器上时，它们会使用EJB进行应用服务器的事务管理能力。在这些管理环境中，你可以使用MANAGED事务管理器。
		注：Managed 是托管的意思，即我们编写的应用程序本身不去管理事务，而是把事务管理交给应用所在的服务器进行管理。

		2.1.4 properties元素
		属性配置元素properties可以将配置值写死到mybatis-config.xml中,也可以具体到一个属性文件中,并且使用属性文件的key名作为占位符.
		在上述的配置中，我们将数据库连接属性配置到了application.properties文件中，并且为driver，URL等属性使用了占位符.

		在applications.properties文件中配置数据库连接参数，如下所示：
		jdbc.driverClassName=oracle.jdbc.driver.OracleDriver
		jdbc.url=jdbc:oracle:thin:@127.0.0.1:1521:XE
		jdbc.username=test
		jdbc.password=test

		在mybatis-config.xml文件中，为属性使用application.properties文件中定义的占位符：
		<!-- 读取application.properties文件中的数据key-value的形式 -->
		<properties resource="application.properties">
		  <!-- 注意:是applications.properties文件中的值优先级高 -->
		  <property name="jdbc.username" value="briup" />
		  <property name="jdbc.password" value="briup" />
		</properties>
		<environments default="development">
			<environment id="development">
			  <transactionManager type="JDBC" />
			  <dataSource type="POOLED">
				<property name="driver" value="${jdbc.driverClassName}" />
				<property name="url" value="${jdbc.url}" />
				<property name="username" value="${jdbc.username}" />
				<property name="password" value="${jdbc.password}" />
			  </dataSource>
			</environment>
		</environments>


		2.1.5 typeAliases元素: 类型别名
		在SQLMapper配置文件中，对于resultType和parameterType属性值，我们需要使用JavaBean 的完全限定名。
		例如:
		<select id="findStudentById" parameterType="int"
			resultType="com.briup.bean.Student">
				SELECT STUD_ID AS ID, NAME, EMAIL, DOB
				FROM STUDENTS WHERE STUD_ID=#{Id}
		</select>
		<update id="updateStudent" parameterType="com.briup.bean.Student">
			UPDATE STUDENTS
				SET NAME=#{name}, EMAIL=#{email}, DOB=#{dob}
				WHERE STUD_ID=#{id}
		</update>

		注:parameterType表示将来调用这个sql语句的时候所传的参数的类型(参数值或者参数对象里面的属性值 用来替换sql语句中的占位符)
		resultType表示将来调用这个sql语句的时候所返回的结果的类型(方便mybatis给我们自动封装结果集)

		这里我们为resultType和parameterType属性值设置为Student类型的完全限定名：com.briup.com.Student

		我们可以为完全限定名取一个别名（alias），然后就可以在需要使用完全限定名的地方使用别名，而不是到处使用完全限定名。如下例子所示，为完全限定名起一个别名：
		<type Aliases>
		  <type Alias alias="Student" type="com.briup.bean.Student" />
		  <type Alias alias="Teacher" type="com.briup.bean.Teacher" />
		</type Aliases>

		然后在SQLMapper映射文件中, 如下使用Student的别名：
		<select id="findStudentById" parameterType="int" resultType="Student">
			SELECT STUD_ID AS ID, NAME, EMAIL, DOB
			FROM STUDENTS WHERE STUD_ID=#{id}
		</select>
		<update id="updateStudent" parameterType="Student">
			UPDATE STUDENTS
				SET NAME=#{name}, EMAIL=#{email}, DOB=#{dob}
			WHERE STUD_ID=#{id}
		</update>

		你可以不用为每一个JavaBean单独定义别名,你可以为配置出需要取别名的类的所在的包(package)，MyBatis会自动扫描包内定义的类，然后分别为每个类注册一个小写字母开头的简单类名形式的别名。如下所示：(使用不区分大小写)
		<type Aliases>
		  <package name="com.briup.bean" />
		</type Aliases>
		如果Student.java和 Teacher.java 定义在com.briup.pojo包中，则 com.briup.bean.Student的别名会被注册为student。而com.briup.bean.Teacher别名将会被注册为teacher

		还有另外一种方式为JavaBeans起别名，使用注解 @Alias:
		@Alias("stu")
		public class Student{
			....
		}
		@Alias注解将会覆盖配置文件中的<typeAliases>定义。
		注意: @Alias 要和<package name=""/>标签配合使用,Mybatis会自动查看指定包内的类别名注解,如果没有这个注解,那么默认的别名就是类的名字


		2.1.6 typeHandlers元素: 类型处理器
		当MyBatis将一个Java对象作为输入参数执行INSERT语句操作时，它会创建一个PreparedStatement对象，并且使用setXXX()方法对?号占位符 设置相应的参数值 。这里，XXX可以是int，String，Date 等 Java对象属性类型的任意一个。示例如下：
		<insert id="insertStudent" parameterType="Student">
			INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL,DOB)
			VALUES(#{studId},#{name},#{email},#{dob})
		</insert>

		为执行这个语句，MyBatis将采取以下一系列动作：
			创建一个有占位符的PreparedStatement接口，如下：
			PreparedStatement ps = connection.prepare Statement
                    ("INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL,DOB) VALUES(?,?,?,?)");
			检查Student对象的属性studId的类型，然后使用合适setXXX方法去设置参数值。这里studId是Integer类型，所以会使用setInt()方法：ps.setInt(1,student.getStudId());

			类似地，对于name和email属性都是String类型MyBatis使用setString()方法设置参数。
			至于dob属性, MyBatis会使用setDate()方法设置dob处占位符位置的值。
			MyBaits会将java.util.Date类型转换为java.sql.Timestamp并设值：
			ps.setTimestamp(4, new Timestamp((student.getDob()).getTime()));

		但MyBatis是怎么知道对于Integer类型属性使用setInt()和String类型属性使用setString()方法呢？其实MyBatis是通过使用类型处理器typeHandlers来决定这么做的。

		MyBatis对于以下的类型使用内置的类型处理器：所有的基本数据类型、基本类型的包装类型、 byte[]、java.util.Date、java.sql.Date、java,sql.Time、java.sql.Timestamp、java枚举类型等。所以当MyBatis发现属性的类型属于上述类型，他会使用对应的类型处理器将值设置到PreparedStatement中，同样地，当SQL结果集封装成java类对象的时候，也有类似的过程。

		那如果有一个自定义的类型，怎么存储存储到数据库呢？示例如下：假设表STUDENTS 有一个 PHONE 字段，类型为 VARCHAR2(15)，而 Student类有一个自定义类型属性phone(PhoneNumber类)

		alter table students add phone varchar2(15);
		alter table students drop column phone;

		java代码:
		PhoneNumber 类定义类型的 phoneNumber 属性。

		public class PhoneNumber{
			private String countryCode;
			private String stateCode;
			private String number;
			public PhoneNumber(){
			}
			public PhoneNumber(String countryCode, String stateCode, String number) {
				this.countryCode = countryCode;
				this.stateCode = stateCode;
				this.number = number;
			}
			public String getAsString() {
				return countryCode + "-" + stateCode + "-" + number;
			}
			// Setters and getters
		}

		public class Student{
			private Integer id;
			private String name;
			private String email;
			private PhoneNumber phone;
			// Setters and getters
		}


		xml配置:
		<insert id="insertStudent" parameter Type="Student">
			insert into students(name,email,phone)
			values(#{name},#{email},#{phone})
		</insert>
		//name--getName( String)--setString()
		//phone--getPhone(PhoneNumber)--setXXX
		这里，参数对象中的属性phone的值需要传递给#{phone}；而参数对象的属性phone是 PhoneNumber类型。但是，MyBatis 并不知道该怎样来处理这个类型的对象。

		为了让MyBatis明白怎样处理这个自定义的Java对象类型，如PhoneNumber，我们可以创建一个自定义的类型处理器,MyBatis提供了抽象类BaseTypeHandler<T> ，我们可以继承此类创建自定义类型处理器。
		代码如下所示:
			package com.briup.typehandlers;

			import java.sql.CallableStatement;
			import java.sql.PreparedStatement;
			import java.sql.ResultSet;
			import java.sql.SQLException;

			import org.apache.ibatis.type.BaseTypeHandler;
			import org.apache.ibatis.type.JdbcType;

			import com.briup.bean.PhoneNumber;

			public class PhoneTypeHandler extends BaseTypeHandler<PhoneNumber>{

				//遇到PhoneNumber参数的时候应该如何在ps中设置值
				@Override
				public void setNonNullParameter(PreparedStatement ps, int i, PhoneNumber parameter, JdbcType jdbcType)
						throws SQLException {
					ps.setString(i, parameter.getAsString());
				}

				//查询中遇到PhoneNumber类型的应该如何封装(使用列名封装)
				@Override
				public PhoneNumber getNullableResult(ResultSet rs, String columnName) throws SQLException {
					return new PhoneNumber(rs.getString(columnName));
				}

				//查询中遇到PhoneNumber类型的应该如何封装(使用列的下标)
				@Override
				public PhoneNumber getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
					return new PhoneNumber(rs.getString(columnIndex));
				}

				//CallableStatement使用中遇到了PhoneNumber类型的应该如何封装
				@Override
				public PhoneNumber getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
					return new PhoneNumber(cs.getString(columnIndex));
				}

			}

		注意:使用ps.setString()和rs.getString()方法是 :因为在数据库的表中phone列是VARCHAR类型。

		最后一旦我们实现了自定义的类型处理器，我们需要在mybatis-config.xml中注册它：
		<?xml version="1.0" encoding="utf-8"?>
		<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
		"http://mybatis.org/dtd/mybatis-3-config.dtd">
		<configuration>
		  <properties resource="application.properties" />
		  <type Handlers>
			<type Handler handlers="com.briup.typehandlers.PhoneTypeHandler" />
		  </type Handlers>
		</configuration>
		注册PhoneTypeHandler后, MyBatis就能够将Phone类型的对象值存储到VARCHAR类型的列上。



		2.1.7 settings元素: 全局参数设置
		注意:大多数情况下，【这些参数使用它们的默认值即可】
		为满足应用特定的需求，MyBatis默认的全局参数设置可以被覆盖掉，如下所示：
		<settings>
		  <setting name="cacheEnabled" value="true" />
		  <setting name="lazyLoadingEnabled" value="true" />
		  <setting name="multipleResultSetsEnabled" value="true" />
		  <setting name="useColumnLabel" value="true" />
		  <setting name="useGeneratedKeys" value="false" />
		  <setting name="autoMappingBehavior" value="PARTIAL" />
		  <setting name="defaultExecutorType" value="SIMPLE" />
		  <setting name="defaultStatementTimeout" value="25000" />
		  <setting name="safeRowBoundsEnabled" value="false" />
		  <setting name="mapUnderscoreToCamelCase" value="false" />
		  <setting name="localCacheScope" value="SESSION" />
		  <setting name="jdbcTypeForNull" value="OTHER" />
		  <setting name="lazyLoadTriggerMethods" value="equals,clone,hash Code ,to String" />
		  <setting name="proxyFactory" value="JAVASSIST" />
		  <setting name="aggressiveLazyLoading" value="true" />
		  <setting name="logImpl" value="LOG4J " />
		  <setting name="logPrefix" value="LOG4J " />
		  <setting name="callSettersOnNulls" value="false " />
		</settings>


		<settings>
		  <!-- 这个配置使全局的映射器启用或禁用缓存 -->
		  <setting name="cacheEnabled" value="true" />

		  <!-- 全局启用或禁用延迟加载。当禁用时，所有关联对象都会即时加载 -->
		  <setting name="lazyLoadingEnabled" value="true" />

		  <!-- 允许或不允许多种结果集从一个单独的语句中返回（需要适合的驱动） -->
		  <setting name="multipleResultSetsEnabled" value="true" />

		  <!-- 使用列标签代替列名。不同的驱动在这方便表现不同。参考驱动文档或充分测试两种方法来决定所使用的驱动 -->
		  <setting name="useColumnLabel" value="true" />

		  <!-- 允许JDBC支持生成的键。需要适合的驱动。 -->
		  <setting name="useGeneratedKeys" value="false" />

		  <!-- 指定MyBatis如何自动映射列到字段/属性。PARTIAL只会自动映射简单、没有嵌套的结果。FULL会自动映射任意复杂的结果（嵌套的或其他情况） -->
		  <setting name="autoMappingBehavior" value="PARTIAL" />

		  <!-- 配置默认的执行器。SIMPLE执行器没有什么特别之处。REUSE执行器重用预处理语句。BATCH执行器重用语句和批量更新 -->
		  <setting name="defaultExecutorType" value="SIMPLE" />

		  !-- 设置超时时间，它决定驱动等待一个数据库响应的时间 -->
		  <setting name="defaultStatementTimeout" value="25000" />

		  <!-- 允许在嵌套语句中使用分页（RowBounds）默认false -->
		  <setting name="safeRowBoundsEnabled" value="false" />

		  <!-- 是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。默认false -->
		  <setting name="mapUnderscoreToCamelCase" value="false" />

		  <!-- MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。 -->
		  <setting name="localCacheScope" value="SESSION" />

		  <!-- 当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。 某些驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。 -->
		  <setting name="jdbcTypeForNull" value="OTHER" />

		  <!-- 指定对象的哪个方法触发一次延迟加载。 -->
		  <setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode ,toString" />

		  <!-- CGLIB | JAVASSIST 默认JAVASSIST(MyBatis 3.3 or above)  -->
		  <!-- 指定 Mybatis 创建具有延迟加载能力的对象所用到的代理工具。 -->
		  <setting name="proxyFactory" value="JAVASSIST" />
		  <!-- 当启用时，对任意延迟属性的调用会使带有延迟加载属性的对象完整加载；反之，每种属性将会按需加载。 -->
		  <setting name="aggressiveLazyLoading" value="true" />

		  <!-- 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 -->
		  <setting name="logImpl" value="LOG4J " />

		  <!-- 指定 MyBatis 增加到日志名称的前缀。值可以是任意字符串 -->
		  <setting name="logPrefix" value="LOG4J " />

		  <!-- 指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这对于有 Map.keySet() 依赖或 null 值初始化的时候是有用的。注意基本类型（int、boolean等）是不能设置成 null 的。 默认false-->
		  <setting name="callSettersOnNulls" value="false " />
		</settings>



		2.1.8 mappers元素: SQL映射
		SQLMapper文件中包含的SQL映射语句将会被应用通过使用其标签中的id值来执行。我们需要在mybatis-config.xml文件中配置SQLMapper文件的位置。
		<mappers>
		  <mapper resource="com/briup/mappers/StudentMapper.xml" />
		  <mapper url="file:///D:/mybatisdemo/app/mappers/StudentMapper.xml" />
		  <mapper class="com.briup.mappers.StudentMapper" />
		  <package name="com.briup.mappers" />
		</mappers>

		以上每一个<mapper> 标签都可以从不同类型的资源中加载映射mapper：
		resource属性用来指定在classpath中的mapper文件。
		url属性用来通过完全文件系统路径或者web URL地址来指向mapper文件
		class属性用来指向一个mapper接口
		package属性用来指向可以找到Mapper接口的包名


	2.2 使用Java API配置MyBatis (属于了解的内容,因为有了灵活的配置配置方法,这个方式几乎不用)
		MyBatis的SqlSessionFactory接口除了使用基于XML的配置创建外也可以通过JavaAPI编程式地被创建。每在XML中配置的元素，都可以编程式的创建。
		因为mybatis框架读取了我们配置的mybatis-config.xml中配置信息之后,然后利用这些信息去执行代码创建出我们需要的SqlSessionFactory,再从而进一步得到sqlSession,最后再进行各种数据库操作。
		所以其实我们完全可以不去配置任何信息直接把信息写在代码中,然后在按着之前的顺序创建出我们需要的SqlSessionFactory,再从而进一步得到sqlSession,最后再进行各种数据库操作。只是这样做再大多数时候都会降低代码的灵活性,所以我们基本上接触的框架都是有相应的配置文件的.

		例如:使用Java API创建SqlSessionFactory对象,之前是读取配置文件之后再创建,现在是自己把信息写到代码中,然后再创建该对象
		public static SqlSessionFactory getSqlSessionFactory() {
			SqlSessionFactory sqlSessionFactory = null;
			try {
				DataSource dataSource = DataSourceFactory.getDataSource();
				TransactionFactory transactionFactory = new JdbcTransactionFactory();
				Environment environment = new Environment("development", transactionFactory, dataSource);
				Configuration configuration = new Configuration(environment);
				configuration.getTypeAliasRegistry().registerAlias("student",Student.class);
				configuration.getTypeHandlerRegistry().register(PhoneNumber.class, PhoneTypeHandler.class);
				configuration.addMapper(StudentMapper.class);
				sqlSessionFactory = new SqlSessionFactoryBuilder().
				build(configuration);
			}
			catch (Exception e) {
				throw new RuntimeException(e);
			}
			return sqlSessionFactory;
		}

		类似的,每个在XML中配置的元素，都可以编程式的创建.
		注:这里就不一一介绍了，因为绝大多数情况下我们还是不会把配置信息直接写到代码中的

	2.3 自定义MyBatis日志
	MyBatis使用其内部LoggerFactory作为真正的日志类库使用的门面。其内部的LaggerFactory会将日志记录任务委托给如下的所示某一个日志实现，日志记录优先级由上到下顺序递减：
	SLF4J
	Apache Commons Logging
	Log4j2
	Log4j
	JDK logging

	如果MyBatis未发现上述日志记录实现，则MyBatis的日志记录功能无效,如果你的运行环境中，在classpath中有多个可用的日志类库，并且你希望MyBaits使用某个特定的日志实现，你可以通过调用以下其中一个方法：
	org.apache.ibatis.logging.LogFactory.useSlf4jLogging();
	org.apache.ibatis.logging.LogFactory.useLog4JLogging();
	org.apache.ibatis.logging.LogFactory.useLog4J2Logging();
	org.apache.ibatis.logging.LogFactory.useJdkLogging();
	org.apache.ibatis.logging.LogFactory.useCommonsLogging();
	org.apache.ibatis.logging.LogFactory.useStdOutLogging();   //不用jar包


	注:
	如果你想自定义MyBatis日志记录，你应该在调用任何其它方法之前调用以上的其中一个方法


三 使用XML配置SQL映射器(映射文件)
	关系型数据库和SQL是经受时间考验和验证的数据存储机制。和其他的ORM 框架如Hibernate不同，MyBatis鼓励开发者可以直接使用数据库，而不是将其对开发者隐藏，因为这样可以充分发挥数据库服务器所提供的SQL语句的巨大威力。
	与此同时，MyBaits消除了书写大量冗余代码的痛苦，它让使用SQL更容易。在代码里直接嵌套SQL语句是很差的编码实践，并且维护起来困难。MyBaits使用了映射文件或注解来配置SQL语句。

	3.1 映射器文件和映射器接口
		我们已经看见了一些在映射器配置文件中配置基本的映射语句，以及怎样使用SqlSession对象调用它们的例子。现在让我们看一下在com.briup.mappers包中的StudentMapper.xml  配置文件内，是如何配置id为”findStudentById”的SQL语句的，代码如下：
		<?xml version="1.0" encoding="utf-8"?>
		<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
		"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
		<mapper namespace="com.briup.mappers.StudentMapper">
		  <select id="findStudentById" parameterType="int" resultType="Student">
			select stud_id as studId, name, email, dob
			from students where stud_id=#{studId}
		  </select>
		</mapper>
		我们可以通过下列代码调用findStudentById映射的SQL语句:
		public Student findStudentById(Integer studId) {
			SqlSession sqlSession = MyBatisSqlSessionFactory.openSession();
			try{
				Student student = sqlSession.selectOne("com.briup.mappers.StudentMapper.findStudentById", studId);
				return student;
			}
			finally {
				sql Session.close();
			}
		}


		我们可以通过字符串（字符串形式为：映射器配置文件所在的包名的namespace + sql语句id值，如上，即包名com.briup.mappers.StudentMapper和语句id的值findStudentById组成）调用映射的SQL语句，但是这种方式容易出错。你需要检查映射器配置文件中的定义，以保证你的输入参数类型和结果返回类型是有效的。

		【重点部分:】
		MyBatis通过使用映射器Mapper接口提供了更好的调用映射语句的方法。一旦我们通过映射器配置文件配置了映射语句，我们可以创建一个完全对应的一个映射器接口，xml映射文件中的namespace属性值和映射接口的全限定名需要保持一致。映射器接口中的方法签名也跟映射器配置文件中完全对应：方法名和配置文件中id值一致；方法参数类型和parameterType属性值一种；方法返回值类型和returnType属性值一致。

		上述的StudentMapper.xml文件,我们可以创建一个映射器接口StudentMapper.java如下：

		package com.briup.mappers;
		public interface StudentMapper{
			Student findStudentById(Integer id);
		}
		在Student Mapper.xml映射器配置文件中，其名空间namespace应该跟StudentMapper接口的全限定名保持一致。另外，StudentMapper.xml中语句id, parameterType，returnType 应该分别和StudentMapper接口中的方法名，参数类型，返回值相对应。

		使用映射器接口我们可以以类型安全的形式调用调用映射语句。如下所示：

		public Student findStudentById(Integer studId){
			SqlSession sqlSession = MyBatisSqlSessionFactory.openSession();
			try {
				StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);

				return student Mapper.findStudentById(studId);
			}
			finally {
				sqlSession.close();
			}
		}

	public void insertStudent(Student student);
	public void insertStudent_autoId(Student student);
	public void insertStudent_autoId2(Student student);
	public void updateStudent(Student student);
	public void deleteStudentById(Integer id);
	public Student findStudentById(Integer id);
	public List<Student> findAllStudents();
	public List<Student> findAllStudents_resultMap();
	public Map<String,Object> findStudentById_Map(Integer id);
	public List<Map<String,Object>> findAllStudents_Map();
	public Set<Student> findAllStudents_Set();
	public SortedSet<Student> findAllStudents_SortedSet();
	public List<String> findAllName_list();
	public int findCount_int();
	3.2 映射语句
	MyBatis提供了多种元素来配置不同类型的语句，如SELECT，INSERT，UPDATE，DELETE。让我们看看如何具体配置映射语句

		3.2.1 INSERT 插入语句
		一个INSERT语句可以在<insert>标签元素在映射器XML配置文件中配置，如下所示：
		<insert id="insertStudent" parameterType="Student">
			INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL, PHONE) VALUES(#{studId},#{name},#{email},#{phone})
		</insert>
		这里我们设置一个ID属性为insertStudent，可以在名空间 com.briup.mappers.StudentMapper.insertStudent中唯一标识该sql语句。parameterType 属性是一个完全限定类名或者是一个类型别名（alias）。

		我们可以如下调用这个语句：
		int count =  sqlSession.insert("com.briup.mappers.StudentMapper.insertStudent", student);
		sqlSession.insert() 方法返回执行 INSERT 语句后所影响的行数。

		如果不使用名空间（namespace）和语句 id 来调用映射语句，你可以通过创建一个映射器Mapper 接口，并以类型安全的方式调用方法，如下所示：
		package com.briup.mappers;
		public interface Student Mapper{
			int insertStudent(Student student);
		}
		你可以如下调用insertStudent映射语句：
		StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);
		int count = mapper.insertStudent(student);

		自动生成主键:
		在上述的INSERT语句中，我们为可以自动生成（auto-generated）主键的列 STUD_ID 插入值。我们可以使用useGeneratedKeys和keyProperty属性让数据库生成auto_increment列的值，并将生成的值设置到其中一个输入对象属性内，如下所示：

		<insert id="insertStudent" parameterType="Student" useGeneratedKeys="true" keyProperty="studId">
			INSERT INTO STUDENTS(NAME, EMAIL, PHONE) VALUES(#{name},#{email},#{phone})
		</insert>
		这里STUD_ID列值将会被数据库自动生成(如mysql)，并且生成的值会被设置到student对象的studId属性上。

		但是有些数据库如Oracle并不支持AUTO_INCREMENT列，其使用序列（SEQUENCE）来生成主键值。假设我们有一个名为my_seq的序列来生成SUTD_ID主键值。使用如下代码来生成主键：
		drop sequence my_seq;
		create sequence my_seq;
		create sequence my_seq
		start with 1
		increment by 1
		nomaxvalue
		nominvalue
		nocycle
		nocache;

		<insert id="insertStudent" parameterType="Student">
			<selectKey keyProperty="studId" resultType="int" order="BEFORE">
				SELECT my_seq.nextval FROM DUAL
			</selectKey>
			INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL, PHONE)
				VALUES(#{studId},#{name},#{email},#{phone})
		</insert>
		这里我们使用了<selectKey>子元素来生成主键值，并将值保存到Student对象的studId 属性上。属性order=“before”表示MyBatis将取得序列的下一个值作为主键值，并且在执行INSERT语句之前将值设置到studId属性上。(程序中的student对象的studId属性)

		注:SelectKey需要注意order属性，像MySQL、SQLServer等一类支持自动增长类型的数据库中，order需要设置为after才会取到正确的值。
		像Oracle这样取序列的情况，需要设置为before，否则会报错。


		3.2.2 UPDATE 更新语句
		一个UPDATE SQL语句可以在<update>元素在映射器XML配置文件中配置，如下所示：
		<update id="updateStudent" parameterType="Student">
			UPDATE STUDENTS SET NAME=#{name}, EMAIL=#{email}, PHONE=#{phone}
			WHERE STUD_ID=#{studId}
		</update>

		我们可以如下调用此语句：
		int noOfRowsUpdated = sqlSession.update("com.briup.mappers.StudentMapper.updateStudent", student);
		sqlSession.update()方法返回执行UPDATE语句之后影响的行数。

		如果不使用名空间（namespace）和语句id来调用映射语句，你可以通过创建一个映射器Mapper接口，并以类型安全的方式调用方法，如下所示：

		package com.briup.mappers;
		public interface StudentMapper{
			int updateStudent(Student student);
		}

		你可以使用映射器Mapper接口来调用updateStudent语句，如下所示：
		StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);
		int noOfRowsUpdated = mapper.updateStudent(student);


		3.2.3 DELETE 删除语句
		一个UPDATE SQL语句可以在<update>元素在映射器XML配置文件中配置，如下所示
		<delete id="deleteStudent" parameterType="int">
		   DELETE FROM STUDENTS WHERE STUD_ID=#{id}
		</delete>

		我们可以如下调用此语句：
		int studId = 1;
		int noOfRowsDeleted = sqlSession.delete("com.briup.mappers.StudentMapper.deleteStudent", studId);
		sqlSession.delete()方法返回 delete 语句执行后影响的行数。

		如果不使用名空间（namespace）和语句 id 来调用映射语句，你可以通过创建一个映射器 Mapper 接口，并以类型安全的方式调用方法，如下所示：
		package com.briup.mappers;
		public interface StudentMapper{
		  int deleteStudent(int studId);
		}
		你可以使用映射器Mapper接口来调用updateStudent语句，如下所示：
		StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);
		int noOfRowsDeleted = mapper.deleteStudent(studId);

		3.2.4 SELECT 查询语句
		MyBatis真正强大的功能，在于映射SELECT查询结果到java的各种类型。
		让我们看看一个简单的select查询是如何（在MyBatis中）配置的，如下所示：
		<select id="findStudentById" parameterType="int"
		resultType="Student">
			SELECT STUD_ID, NAME, EMAIL, PHONE
				FROM STUDENTS
			WHERE STUD_ID=#{stud Id}
		</select>
		我们可以如下调用此语句：
		int studId = 1;
		Student student = sqlSession.selectOne("com.briup.mappers. StudentMapper.findStudentById", studId);

		如果不使用名空间（namespace）和语句 id 来调用映射语句，你可以通过创建一个映射器 Mapper 接口，并以类型安全的方式调用方法，如下所示：
		package com.briup.mappers;
		public interface StudentMapper{
			Student findStudentById(Integer studId);
		}
		你可以使用映射器Mapper接口来调用 findStudentById 语句，如下所示：
		StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);
		Student student = mapper.findStudentById(studId);

		如果你检查Student对象的属性值，你会发现studId属性值并没有被stud_id列值填充。这是因为MyBatis自动对java对象中和列名匹配的属性进行填充。这就是为什么name,email和 phone属性被填充而studId属性没有被填充。
		解决这一问题，我们可以为列名起一个可以与JavaBean中属性名匹配的别名，如下所示：
		<select id="findStudentById" parameterType="int"
		resultType="Student">
			SELECT STUD_ID AS studId, NAME,EMAIL, PHONE
				FROM STUDENTS
			WHERE STUD_ID=#{studId}
		</select>


		MyBatis执行返回多条结果的SELECT语句查询，如下所示：
		<select id="findAllStudents" resultType="Student">
			SELECT STUD_ID AS studId, NAME,EMAIL, PHONE
			FROM STUDENTS
		</select>

		List<Student> students =
		sqlSession.selectList("com.briup.mappers.StudentMapper.findAllStudents");

		映射器 Mapper 接口 StudentMapper 可以如下定义：
		package com.briup.mappers;
		public interface StudentMapper{
			List<Student> findAllStudents();
		}

		使用上述代码，我们可以如下调用
		StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);
		List<Student> students = mapper.findAllStudents();

		如果你注意到上述的SELECT映射定义，你可以看到，我们为所有的映射语句中的stud_id 起了别名。我们可以使用ResultMaps，来避免上述的到处重复别名。我们稍后会继续讨论。
		除了java.util.List，你也可以使用其他类型的集合类，如Set,Map，以及（SortedSet）。MyBatis 根据集合的类型，会采用适当的集合实现，如下所示：
		对于List，Collection，Iterable类型，MyBatis将返回java.util.ArrayList
		对于Map类型，MyBatis 将返回java.util.HashMap 
		对于Set类型，MyBatis 将返回java.util.HashSet
		对于SortedSet类型，MyBatis将返回java.util.TreeSet

	3.3 结果集映射 ResultMaps
		ResultMaps被用来将SELECT语句的结果集映射到java对象的属性中。我们可以定义结果集映射ResultMaps并且在一些SELECT语句上引用resultMap。MyBatis的结果集映射 ResultMaps特性非常强大，你可以使用它将简单的SELECT语句映射到复杂的一对一、一对多关系的SELECT语句上。


		3.3.1 简单ResultMap
		一个映射了查询结果为Student类型的resultMap定义如下：
		<resultMap id="StudentResult" type="com.briup.bean.Student">
		  <id property="studId" column="stud_id" />
		  <result property="name" column="name" />
		  <result property="email" column="email" />
		  <result property="phone" column="phone" />
		</resultMap>

		<select id="findAllStudents" resultMap="StudentResult">
			SELECT * FROM STUDENTS
		</select>
		<select id="findStudentById" parameterType="int" resultMap="StudentResult">
			SELECT * FROM STUDENTS WHERE STUD_ID=#{studId}
		</select>

		resultMap的id值应该在此名空间内是唯一的,并且type属性是完全限定类名或者是返回类型的别名。
		<result>子元素被用来将一个resultset列映射到对象的一个属性中。
		<id>元素和<result>元素功能相同，不过<id>它被用来映射到唯一标识属性，用来区分和比较对象（一般和主键列相对应）。
		在<select>语句中，我们使用了resultMap属性，而不是resultType属性。当<select>语句中配置了resutlMap属性，MyBatis会使用表中的列名与对象属性 【映射关系】 来填充对象中的属性值。

		注意:resultType和resultMap二者只能用其一，不能同时使用。


		<select>映射语句中如何将查询【一条】数据填充到HashMap中?
		<select id="findStudentById" parameterType="int" resultType="map">
			SELECT * FROM STUDENTS WHERE STUD_ID=#{studId}
		</select>
		在上述的<select>语句中，我们将resultType配置成map，即java.util.HashMap的别名。在这种情况下，结果集的列名将会作为Map中的key值，而列值将作为Map的value值。

		HashMap<String,Object> studentMap = sqlSession.selectOne("com.briup.mappers.StudentMapper.findStudentById", studId);
		System.out.println("stud_id :"+studentMap.get("stud_id"));
		System.out.println("name :"+studentMap.get("name"));
		System.out.println("email :"+studentMap.get("email"));
		System.out.println("phone :"+studentMap.get("phone"));



		<select>映射语句中如何将查询【多条】数据填充到HashMap中?
		<select id="findAllStudents" resultType="map">
			SELECT STUD_ID, NAME, EMAIL, PHONE FROM STUDENTS
		</select>

		由于resultType=”map”和语句返回多行，则最终返回的数据类型应该是List<Map<String,Object>>，如下所示：

		List<Map<String, Object>> studentMapList = sqlSession.select List("com.briup.mappers.StudentMapper.findAllStudents");
		for(Map<String, Object> studentMap : studentMapList) {
		System.out.println("studId :" + studentMap.get("stud_id"));
			System.out.println("name :" + studentMap.get("name"));
			System.out.println("email :" + studentMap.get("email"));
			System.out.println("phone :" + studentMap.get("phone"));
		}


		其他实例1:
		<select id="findAllStudents_student" resultType="Student">
			SELECT STUD_ID AS STUDID,NAME,EMAIL,DOB
			FROM STUDENTS
		</select>
		对应的接口中的方法,你写什么类型的集合,Mybatis就给你返回什么类型的集合,但是要注意使用SortedSet的时候,Student类需要实现Comparable接口,否则是不能进行排序的
		例如:
		public List<Student> findAllStudents_List();
		或者
		public Set<Student> findAllStudents_Set();
		或者
		public SortedSet<Student> findAllStudents_SortedSet();


		其他实例2:
		<select id="findAllName_list" resultType="String">
			SELECT NAME
			FROM STUDENTS
		</select>
		对应的接口中的方法: 把查询到所有名字都放到List集合中并返回
		public List<String> findAllName_list();


		其他实例3:
		<select id="findCount_int" resultType="int">
			SELECT count(*)
			FROM STUDENTS
		</select>
		对应的接口中的方法: 把查询到的这个值直接返回
		public int findCount_int();


		3.3.2 拓展 ResultMap
		(注:这个可以在下面的一对一映射中进行测试,因为这里需要建立一对一关系的表结构)
		我们可以从从另外一个<resultMap>，拓展出一个新的<resultMap>，这样，原先的属性映射可以继承过来，以实现:
		<resultMap type="Student" id="StudentResult">
		  <id property="stud Id" column="stud_id" />
		  <result property="name" column="name" />
		  <result property="email" column="email" />
		  <result property="phone" column="phone" />
		</resultMap>

		<!-- Student类中又新增加了一个属性,该属性的类型是Address -->
		<!-- 自定义类Address,类中也有多个属性,同时数据库中ADDRESSES表与其对应 -->
		<resultMap type="Student" id="StudentWithAddressResult" extends="StudentResult">
		  <result property="address.addrId" column="addr_id" />
		  <result property="address.street" column="street" />
		  <result property="address.city" column="city" />
		  <result property="address.state" column="state" />
		  <result property="address.zip" column="zip" />
		  <result property="address.country" column="country" />
		</resultMap>

		其中id为StudentWithAddressResult的resultMap拓展了id为StudentResult的resultMap

		如果你只想映射Student数据，你可以使用id为StudentResult的resultMap,如下所示：

		<select id="findStudentById" parameterType="int"
		resultMap="StudentResult">
			SELECT * FROM STUDENTS WHERE STUD_ID=#{stud Id}
		</select>

		如果你想将映射Student数据和Address数据，你可以使用id为StudentWithAddressResult的 resultMap：
		<select id="selectStudentWithAddress" parameterType="int"
		resultMap="StudentWithAddressResult">
			SELECT STUD_ID, NAME, EMAIL, PHONE, A.ADDR_ID, STREET, CITY, STATE, ZIP, COUNTRY
			FROM STUDENTS S LEFT OUTER JOIN ADDRESSES A ON
					S.ADDR_ID=A.ADDR_ID
			WHERE STUD_ID=#{studId}
		</select>
		注:该sql语句使用了连接查询中的左外连接,也可以使用等值连接

	3.4 一对一映射
		Student和Address是一个【一对一】关系
		建表语言:
		drop table students;
		drop table addresses;
		如果需要可以使用 cascade constraints;

		create table addresses(
		  addr_id number primary key,
		  street varchar2(50) not null,
		  city varchar2(50) not null,
		  state varchar2(50) not null,
		  zip varchar2(10),
		  country varchar2(50)
		);

		create table students(
		  stud_id number primary key,
		  name varchar2(50) not null,
		  email varchar2(50),
		  phone varchar2(15),
		  dob date ,
		  addr_id number references addresses(addr_id)
		);

		java类:
		public class PhoneNumber {
			private String countryCode;
			private String stateCode;
			private String number;
			get/set
		}
		public class Address{
			private Integer addrId;
			private String street;
			private String city;
			private String state;
			private String zip;
			private String country;
			get/set
		}
		public class Student {
			private Integer studId;
			private String name;
			private String email;
			private Date dob;
			private PhoneNumber phone;
			private Address address;
			get/set
		}


		addresses 表的样例输入如下所示：
		addr_id  street		city	 state	zip   country
			1	 redSt		kunshan   W		12345  china
			2	 blueST		kunshan   W	    12345  china

		insert into addresses(addr_id,street,city,state,zip,country) values(1,'redSt','kunshan','W','12345','china');
		insert into addresses(addr_id,street,city,state,zip,country) values(2,'blueST','kunshan','W','12345','china');


		students 表的样例数据如下所示：
		stud_id  name    email			phone		addr_id
		   1    John  john@gmail.com  123-456-7890   1
		   2    Paul  paul@gmail.com  111-222-3333   2

		insert into students(stud_id,name,email,phone,addr_id) values(1,'John','john@gmail.com','123-456-7890',1);
		insert into students(stud_id,name,email,phone,addr_id) values(2,'Paul','paul@gmail.com','111-222-3333',2);


		mapper XML:
		一对一 基本的查询映射

		<resultMap type="Student" id="StudentWithAddressResult">
		  <id property="studId" column="stud_id" />
		  <result property="name" column="name" />
		  <result property="email" column="email" />
		  <result property="phone" column="phone" />
		  <result property="address.addrId" column="addr_id" />
		  <result property="address.street" column="street" />
		  <result property="address.city" column="city" />
		  <result property="address.state" column="state" />
		  <result property="address.zip" column="zip" />
		  <result property="address.country" column="country" />
		</resultMap>
		<select id="findStudentByIdWithAddress" parameterType="int" resultMap="StudentWithAddressResult">
			select stud_id, name, email,phone, a.addr_id, street, city, state, zip, country
			from students s left outer join addresses a on
				s.addr_id=a.addr_id
			where stud_id=#{studid}
		</select>

		我们可以使用(对象.属性名)的方式为内嵌的对象的属性赋值。在上述的resultMap中，Student的address属性使用该方式被赋上了 address 对应列的值。同样地，我们可以访问【任意深度】的内嵌对象的属性。

		//接口定义
		public interface Student Mapper{
			Student findStudentByIdWithAddress(int studId);
		}

		//方法调用
		int studId = 1;
		StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);
		Student student = studentMapper.selectStudentWithAddress(studId);
		System.out.println("Student :" + student);
		System.out.println("Address :" + student.getAddress());


		上面展示了一对一关联映射的一种方法。然而，使用这种方式映射，如果address结果需要在其他的SELECT映射语句中映射成Address对象，我们需要为每一个语句重复这种映射关系。MyBatis提供了更好地实现一对一关联映射的方法：【嵌套结果】ResultMap和【嵌套查询】select语句。接下来，我们将讨论这两种方式。




		3.4.1 使用嵌套结果ResultMap实现一对一关系映射
		我们可以使用一个嵌套结果ResultMap方式来获取Student及其Address信息，代码如下：
		<resultMap type="Address" id="AddressResult">
		  <id property="addrId" column="addr_id" />
		  <result property="street" column="street" />
		  <result property="city" column="city" />
		  <result property="state" column="state" />
		  <result property="zip" column="zip" />
		  <result property="country" column="country" />
		</resultMap>
		<resultMap type="Student" id="StudentWithAddressResult">
		  <id property="studId" column="stud_id" />
		  <result property="name" column="name" />
		  <result property="email" column="email" />
		  <result property="dob" column="dob" />
		  <result property="phone" column="phone" />
		  <association property="address" resultMap="AddressResult" />
		</resultMap>
		<select id="findStudentByIdWithAddress" parameterType="int" resultMap="StudentWithAddressResult">
			select stud_id, name, email,dob,phone, a.addr_id, street, city, state, zip, country
			from students s left outer join addresses a
			on s.addr_id=a.addr_id
			where stud_id=#{studid}
		</select>

		注:association是关联的意思
		元素<association>被用来导入“有一个”(has-one)类型的关联。在上述的例子中，我们使用了<association>元素引用了另外的在同一个XML文件中定义的<resultMap>。

		同时我们也可以使用<association> 定义内联的resultMap，代码如下所示：
		<resultMap type="Student" id="StudentWithAddressResult">
		  <id property="studId" column="stud_id" />
		  <result property="name" column="name" />
		  <result property="email" column="email" />
		  <association property="address" javaType="Address">
			<id property="addrId" column="addr_id" />
			<result property="street" column="street" />
			<result property="city" column="city" />
			<result property="state" column="state" />
			<result property="zip" column="zip" />
			<result property="country" column="country" />
		  </association>
		</resultMap>


		3.4.2 使用嵌套查询select实现一对一关系映射
		我们可以通过使用嵌套select查询来获取Student及其Address信息，代码如下：
		<resultMap id="AddressResult" type="Address">
		  <id property="addrId" column="addr_id" />
		  <result property="street" column="street" />
		  <result property="city" column="city" />
		  <result property="state" column="state" />
		  <result property="zip" column="zip" />
		  <result property="country" column="country" />
		</resultMap>
		<select id="findAddressById" parameterType="int" resultMap="AddressResult">
			select * from addresses where addr_id=#{id}
		</select>

		<resultMap id="findStudentByIdWithAddress" type="Student">
		  <id property="studId" column="stud_id" />
		  <result property="name" column="name" />
		  <result property="email" column="email" />
		  <result property="dob" column="dob" />
		  <result property="phone" column="phone" />
		  <association property="address" column="addr_id" select="findAddressById" />
		</resultMap>
		<select id="findStudentByIdWithAddress" parameterType="int" resultMap="findStudentByIdWithAddress">
			select * from students where stud_id=#{id}
		</select>

		在此方式中，<association>元素的select属性被设置成了id为findAddressById的语句。这里，两个分开的SQL语句将会在数据库中分别执行，第一个调用findStudentById加载student信息，而第二个调用findAddressById来加载address信息。
		addr_id列的值将会被作为输入参数传递给selectAddressById语句。

		我们可以如下调用findStudentWithAddress映射语句：
		StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);
		Student student = mapper.selectStudentWithAddress(studId);
		System.out.println(student);
		System.out.println(student.getAddress());

		添加注意先后顺序
		mapper.xml:
		<insert id="insertAddress" parameterType="Address">
			<selectKey resultType="int" keyProperty="addrId" order="BEFORE">
				select my_seq.nextval from dual
			</selectKey>
			insert into addresses(addr_id,street,city,state,zip,country)
			values(#{addrId},#{street},#{city},#{state},#{zip},#{country})
		</insert>

		<insert id="insertStudent" parameterType="Student">
			<selectKey resultType="int" keyProperty="studId" order="BEFORE">
				select my_seq.nextval from dual
			</selectKey>
			insert into students(stud_id,name,email,dob,phone,addr_id)
			values(#{studId},#{name},#{email},#{dob},#{phone},#{address.addrId})
		</insert>

		//接口定义
		public void insertAddress(Address address);
		public void insertStudent(Student student);

		//Test:
		One2OneMapper mapper = session.getMapper(One2OneMapper.class);
			Address address = new Address("学院路", "昆山", "巴城", "12345", "中国");
			PhoneNumber phone = new PhoneNumber("110-119-120");
			Student student = new Student("张三", "zs@qq.com", new Date(), phone, address);

			mapper.insertAddress(address);
			mapper.insertStudent(student);

			session.commit();

	3.5 一对多映射
		一个讲师tutors可以教授一个或者多个课程course。这意味着讲师和课程之间存在一对多的映射关系。
		注意:在一对多关系中,数据库建表的时候外键一定是在多的那一方建立.
		建表语句:
		drop table tutors;
		drop table courses;
		如果需要可以使用 cascade constraints;

		create table tutors(
		  tutor_id number primary key,
		  name varchar2(50) not null,
		  email varchar2(50) ,
		  phone varchar2(15) ,
		  addr_id number(11) references addresses (addr_id)
		);

		create table courses(
		  course_id number primary key,
		  name varchar2(100) not null,
		  description varchar2(512),
		  start_date date ,
		  end_date date ,
		  tutor_id number references tutors (tutor_id)
		);

		tutors 表的样例数据如下：
		tutor_id   name     email		  phone		addr_id
			1		zs  zs@briup.com   123-456-7890    1
			2		ls  ls@briup.com   111-222-3333    2

		insert into tutors(tutor_id,name,email,phone,addr_id)
		values(1,'zs','zs@briup.com','123-456-7890',1);
		insert into tutors(tutor_id,name,email,phone,addr_id)
		values(2,'ls','ls@briup.com','111-222-3333',2);

		course 表的样例数据如下：
		course_id  name  description  start_date   end_date  tutor_id
			1	 corejava    JavaSE      2015-09-10  2016-02-10   1
			2	 oracle    db      2015-09-10  2016-03-10   2
			3	 html   web     2015-09-10  2016-02-20   1

		insert into
		courses(course_id,name,description,start_date,end_date,tutor_id)
		values(1,'corejava','JavaSE',to_date('2015-09-10','yyyy-mm-dd'),to_date('2016-02-10','yyyy-mm-dd'),1);

		insert into
		courses(course_id,name,description,start_date,end_date,tutor_id)
		values(2,'oracle','db',to_date('2015-09-10','yyyy-mm-dd'),to_date('2016-03-10','yyyy-mm-dd'),2);

		insert into
		courses(course_id,name,description,start_date,end_date,tutor_id)
		values(3,'html','web',to_date('2015-09-10','yyyy-mm-dd'),to_date('2016-02-20','yyyy-mm-dd'),1);
		commit;

		在上述的表数据中，zs 讲师教授一个课程，而 ls 讲师教授两个课程

		java代码:
		public class Tutor{
			private Integer tutorId;
			private String name;
			private String email;
			private PhoneNumber phone;
			private Address address;
			private List<Course> courses;

			get/set
		}

		public class Course{
			private Integer courseId;
			private String name;
			private String description;
			private Date startDate;
			private Date endDate;

			get/set
		}

		<collection>元素被用来将多行课程结果映射成一个课程Course对象的一个集合。和一对一映射一样，我们可以使用【嵌套结果ResultMap】和【嵌套查询Select】语句两种方式映射实现一对多映射。


		3.5.1 使用内嵌结果 ResultMap 实现一对多映射
		我们可以使用嵌套结果resultMap方式获得讲师及其课程信息，代码如下：
		<resultMap type="Address" id="AddressResult">
		  <id property="addrId" column="addr_id" />
		  <result property="street" column="street" />
		  <result property="city" column="city" />
		  <result property="state" column="state" />
		  <result property="zip" column="zip" />
		  <result property="country" column="country" />
		</resultMap>
		<resultMap type="Course" id="CourseResult">
		  <id column="course_id" property="courseId" />
		  <result column="name" property="name" />
		  <result column="description" property="description" />
		  <result column="start_date" property="startDate" />
		  <result column="end_date" property="endDate" />
		</resultMap>
		<resultMap type="Tutor" id="TutorResult">
		  <id column="tutor_id" property="tutorId" />
		  <result column="name" property="name" />
		  <result column="email" property="email" />
		  <result column="phone" property="phone" />
		  <association property="address" resultMap="AddressResult" />
		  <collection property="courses" resultMap="CourseResult" />
		</resultMap>

		<select id="findTutorById" parameterType="int" resultMap="TutorResult">
			select t.tutor_id, t.name, t.email, c.course_id, c.name, description, start_date, end_date,a.addr_id,a.street,a.city,a.state,a.zip,a.country
			from tutors t left outer join addresses a on t.addr_id=a.addr_id
			left outer join courses c on t.tutor_id=c.tutor_id
			where t.tutor_id=#{tutorid}
		</select>

		这里我们使用了一个简单的使用了JOINS连接的Select语句获取讲师及其所教课程信息。<collection>元素的resultMap属性设置成了CourseResult，CourseResult包含了Course对象属性与表列名之间的映射。
		如果同时也要查询到Address相关信息,可以按照上面一对一的方式,在配置中加入<association>即可


		3.5.2 使用嵌套Select语句实现一对多映射
		我们可以使用嵌套Select语句方式获得讲师及其课程信息，代码如下：
		<resultMap type="Address" id="AddressResult">
		  <id property="addrId" column="addr_id" />
		  <result property="street" column="street" />
		  <result property="city" column="city" />
		  <result property="state" column="state" />
		  <result property="zip" column="zip" />
		  <result property="country" column="country" />
		</resultMap>
		<resultMap type="Course" id="CourseResult">
		  <id column="course_id" property="courseId" />
		  <result column="name" property="name" />
		  <result column="description" property="description" />
		  <result column="start_date" property="startDate" />
		  <result column="end_date" property="endDate" />
		</resultMap>

		<resultMap type="Tutor" id="TutorResult">
		  <id column="tutor_id" property="tutorId" />
		  <result column="tutor_name" property="name" />
		  <result column="email" property="email" />
		  <association property="address" column="addr_id" select="findAddressById"></association>
		  <!-- 这里要注意:是把当前tutor_id表中列的值当做参数去执行findCoursesByTutor这个查询语句,最后把查询结果封装到Tutor类中的courses属性中 -->
		  <collection property="courses" column="tutor_id" select="findCoursesByTutor" />
		</resultMap>
		<select id="findTutorById" parameterType="int" resultMap="TutorResult">
			select *
			from tutors
			where tutor_id=#{tutor_id}
		</select>
		<select id="findAddressById" parameterType="int" resultMap="AddressResult">
			select *
			from addresses
			where addr_id = #{addr_id}
		</select>
		<select id="findCoursesByTutor" parameterType="int" resultMap="CourseResult">
		   select *
		   from courses
		   where tutor_id=#{tutor_id}
		</select>

		在这种方式中，<aossication>元素的select属性被设置为id为findCourseByTutor的语句，用来触发单独的SQL查询加载课程信息。tutor_id这一列值将会作为输入参数传递给 findCouresByTutor语句。

		mapper接口代码:
		public interface TutorMapper{
			Tutor findTutorById(int tutorId);
		}

		//方法调用
		TutorMapper mapper = sqlSession.getMapper(TutorMapper.class);
		Tutor tutor = mapper.findTutorById(tutor Id);
		System.out.println(tutor);
		List<Course> courses = tutor.getCourses();
		for (Course course : courses){
			System.out.println(course);
		}

		【注意】嵌套查询Select语句查询会导致1+N选择问题。首先，主查询将会执行（1 次），对于主查询返回的每一行，另外一个查询将会被执行（主查询 N 行，则此查询 N 次）。对于大量数据而言，这会导致很差的性能问题。

	3.5 多对多映射
		对于在mybatis中的多对多的处理,其实我们可以参照一对多来解决
		【注意】在这个例子中有三个字段都是一样的:id,这种情况一定要小心,要给列起别名的(上面的一对一和一对多中如果出现这种情况也是一样的处理方式)
		建表语句:
		drop table student_course;
		drop table course;
		drop table student;
		如果需要可以使用 cascade constraints;

		create table course (
		  id number primary key,
		  course_code varchar2(30) not null,
		  course_name varchar2(30) not null
		);
		create table student (
		  id number primary key,
		  name varchar2(10) not null,
		  gender varchar2(10) ,
		  major varchar2(10) ,
		  grade varchar2(10)
		);
		create table student_course (
		  id number primary key,
		  student_id number references student(id),
		  course_id number references course(id)
		);

		java代码:
		public class Course {
			private Integer id;
			private String courseCode; // 课程编号
			private String courseName;// 课程名称
			private List<Student> students;// 选课学生
			get/set
		}
		public class Student {
			private Integer id;
			private String name; // 姓名
			private String gender; // 性别
			private String major; // 专业
			private String grade; // 年级
			private List<Course> courses;// 所选的课程
			get/set
		}

		Many2ManyMapper.java:
		public interface Many2ManyMapper {
			//插入student数据
			public void insertStudent(Student student);
			//插入course数据
			public void insertCourse(Course course);
			//通过id查询学生
			public Student getStudentById(Integer id);
			//通过id查询课程
			public Course getCourseById(Integer id);

			//学生x选课y
			public void studentSelectCourse(Student student, Course course);
			//查询比指定id值小的学生信息
			public List<Student> getStudentByIdOnCondition(Integer id);
			//查询student级联查询出所选的course并且组装成完整的对象
			public Student getStudentByIdWithCourses(Integer id);
		}


		Many2ManyMapper.xml:
		<insert id="insertStudent" parameterType="Student">
			<selectKey keyProperty="id" resultType="int" order="BEFORE">
				select my_seq.nextval from dual
			</selectKey>
			insert into
				student(id,name,gender,major,grade)
			values
				(#{id},#{name},#{gender},#{major},#{grade})
		</insert>

		<insert id="insertCourse" parameterType="Course">
			<selectKey keyProperty="id" resultType="int" order="BEFORE">
				select my_seq.nextval from dual
			</selectKey>
			insert into
				course(id,course_code,course_name)
			values
				(#{id},#{courseCode},#{courseName})
		</insert>

		<select id="getStudentById" parameterType="int" resultType="Student">
			select id,name,gender,major,grade
			from student
			where id=#{id}
		</select>

		<select id="getCourseById" parameterType="int" resultType="Course">
			select id,course_code as courseCode,course_name as courseName
			from course
			where id=#{id}
		</select>

		<!-- param1代表方法中第一个参数 以此类推 -->
		<insert id="studentSelectCourse">
			insert into
				student_course(id,student_id,course_id)
			values
				(my_seq.nextval,#{param1.id},#{param2.id})
		</insert>

		<!-- 如果有特殊符号的话 需要用 <![CDATA[ 特殊符号 ]]>  例如 < & 等等 -->
		<select id="getStudentByIdOnCondition" parameterType="int" resultType="Student">
			select *
			from student
			where id <![CDATA[ < ]]> #{id}
		</select>

		<!--
			 这里使用了嵌套结果ResultMap的方式进行级联查询
			 当然也可以使用嵌套查询select
		-->
		<!-- 映射一个基本的Student查询结果 -->
		<resultMap id="StudentResult" type="Student">
			<id property="id" column="id"/>
			<result property="name" column="name"/>
			<result property="gender" column="gender"/>
			<result property="major" column="major"/>
			<result property="grade" column="grade"/>
		</resultMap>
		<!-- 继承上面那个基本的映射,再扩展出级联查询 -->
		<resultMap id="StudentResultWithCourses" type="Student" extends="StudentResult">
			<collection property="courses" resultMap="CourseResult"></collection>
		</resultMap>
		<!-- 这里特别要是的是column="cid" 这是和select语句中的 c.id as cid对应的 一定一定一定要对应起来 -->
		<resultMap id="CourseResult" type="Course">
			<id property="id" column="cid"/>
			<result property="courseCode" column="course_code"/>
			<result property="courseName" column="course_name"/>
		</resultMap>
		<!--
			注意:查询语句的中的c.id as cid这个地方,避免名字相同出现查询结果不正确的情况
			同时在id="CourseResult"的resultMap中也有与这里对应的设置要特别特别注意
		-->
		<select id="getStudentByIdWithCourses" parameterType="int" resultMap="StudentResultWithCourses">
			select s.id,s.name,s.gender,s.major,s.grade,c.id as cid,c.course_code,c.course_name,sc.id,sc.student_id,sc.course_id
			from student s,course c,student_course sc
			where
			s.id=#{id}
			and
			s.id=sc.student_id
			and
			sc.course_id=c.id
		</select>

		测试代码:
		@Test
		public void test_insertStudent(){

			SqlSession session = null;
			try {
				session = MyBatisSqlSessionFactory.openSession();

				Many2ManyMapper mapper = session.getMapper(Many2ManyMapper.class);

				mapper.insertStudent(new Student("张三","男","计算机","大四"));

				session.commit();

			} catch (Exception e) {
				e.printStackTrace();
				session.rollback();
			}finally {
				if(session!=null)session.close();
			}

		}

		@Test
		public void test_insertCourse(){

			SqlSession session = null;
			try {
				session = MyBatisSqlSessionFactory.openSession();

				Many2ManyMapper mapper = session.getMapper(Many2ManyMapper.class);

				mapper.insertCourse(new Course("001","corejava"));
				mapper.insertCourse(new Course("002","oracle"));

				session.commit();

			} catch (Exception e) {
				e.printStackTrace();
				session.rollback();
			}finally {
				if(session!=null)session.close();
			}

		}

		@Test
		public void test_studentSelectCourse(){

			SqlSession session = null;
			try {
				session = MyBatisSqlSessionFactory.openSession();

				Many2ManyMapper mapper = session.getMapper(Many2ManyMapper.class);

				Student student = mapper.getStudentById(58);
				Course course = mapper.getCourseById(59);

				mapper.studentSelectCourse(student, course);

				session.commit();

			} catch (Exception e) {
				e.printStackTrace();
				session.rollback();
			}finally {
				if(session!=null)session.close();
			}

		}

		@Test
		public void test_getStudentByIdOnCondition(){

			SqlSession session = null;
			try {
				session = MyBatisSqlSessionFactory.openSession();

				Many2ManyMapper mapper = session.getMapper(Many2ManyMapper.class);

				List<Student> list = mapper.getStudentByIdOnCondition(100);

				for(Student s:list){
					System.out.println(s);
				}

			} catch (Exception e) {
				e.printStackTrace();
			}finally {
				if(session!=null)session.close();
			}

		}

		@Test
		public void test_getStudentByIdWithCourses(){

			SqlSession session = null;
			try {
				session = MyBatisSqlSessionFactory.openSession();

				Many2ManyMapper mapper = session.getMapper(Many2ManyMapper.class);

				Student student = mapper.getStudentByIdWithCourses(58);

				System.out.println(student);

			} catch (Exception e) {
				e.printStackTrace();
			}finally {
				if(session!=null)session.close();
			}

		}

		<select id="getStudentByIdWithCourses2" parameterType="int" resultMap="StudentResultWithCourses2">
			select s.id,s.name,s.gender,s.major,s.grade
			from student s
			where
			s.id=#{id}
		</select>
		<resultMap id="StudentResultWithCourses2" type="Student" extends="StudentResult">
			<collection property="courses" column="id" select="findCoursesByStudentId"></collection>
		</resultMap>
		<select id="findCoursesByStudentId" parameterType="int" resultMap="CourseResult2">
			select * from course
			where id in (
				select course_id
				from student_course
				where student_id = #{id}
			)
		</select>
		<resultMap id="CourseResult2" type="Course">
			<id property="id" column="id"/>
			<result property="courseCode" column="course_code"/>
			<result property="courseName" column="course_name"/>
		</resultMap>


		注:这是从student这边出发所做的一些操作,从course一边开始操作是一样的,因为俩者的关系是多对多(对称的).
		同时不论是一对一还是一对多还是多对多,都不能在mybatis中进行级联保存、更新、删除,我们需要使用sql语句控制每一步操作



	3.6 动态SQL  dynamic-sql
		有时候，静态的SQL语句并不能满足应用程序的需求。我们可以根据一些条件，来动态地构建 SQL语句。
		例如，在Web应用程序中，有可能有一些搜索界面，需要输入一个或多个选项，然后根据这些已选择的条件去执行检索操作。在实现这种类型的搜索功能，我们可能需要根据这些条件来构建动态的SQL语句。如果用户提供了任何输入条件，我们需要将那个条件添加到SQL语句的WHERE子句中。MyBatis通过使用<if>,<choose>,<where>,<foreach>,<trim>元素提供了对构造动态SQL语句的高级别支持。


		3.6.1 If 条件
		<if>元素被用来有条件地嵌入SQL片段，如果测试条件被赋值为true，则相应地SQL片段将会被添加到SQL语句中。假定我们有一个课程搜索界面，设置了讲师（Tutor）下拉列表框，课程名称（CourseName）文本输入框，开始时间（StartDate）输入框，结束时间（EndDate）输入框，作为搜索条件。假定课讲师下拉列表是必须选的，其他的都是可选的。
		当用户点击搜索按钮时，我们需要显示符合以下条件的成列表：
			特定讲师的课程
			课程名
			包含输入的课程名称关键字的课程；如果课程名称输入为空，则取所有课程
			在开始时间和结束时间段内的课程
		我们可以对应的映射语句，如下所示：

		<resultMap type="Course" id="CourseResult">
		  <id column="course_id" property="courseId" />
		  <result column="name" property="name" />
		  <result column="description" property="description" />
		  <result column="start_date" property="startDate" />
		  <result column="end_date" property="endDate" />
		</resultMap>

		<select id="searchCourses" parameterType="map" resultMap="CourseResult">
			SELECT * FROM COURSES
				WHERE TUTOR_ID= #{tutorId}
			<if test="courseName != null">
				AND NAME LIKE #{courseName}
			</if>
			<if test="startDate != null">
				AND START_DATE >= #{startDate}
			</if>
			<if test="endDate != null">
				AND END_DATE <![CDATA[ <= ]]> #{endDate}
			</if>
		</select>

		public interface DynamicSqlMapper{
			List<Course> searchCourses(Map<String, Object> map);
		}
		public void searchCourses(){
			Map<String,Object> map = new HashMap<String,Object>();
			map.put("tutorId", 1);
			map.put("courseName", "%java%");
			map.put("startDate", new Date());
			DynamicSqlMapper mapper = sqlSession.getMapper(DynamicSqlMapper.class);
			List<Course> courses = mapper.searchCourses(map);
			for (Course course : courses){
				System.out.println(course);
			}
		}
		此处将生成查询语句SELECT * FROM COURSES WHERE TUTOR_ID= ? AND NAME like ? AND START_DATE >= ?。


		3.6.2 choose,when 和 otherwise 条件
		有时候，查询功能是以查询类别为基础的。首先，用户需要先选择是否希望通过选择讲师，课程名称，开始时间，或结束时间作为查询条件类别来进行查询，然后根据选择的查询类别，输入相应的参数。在这样的情景中，我们【需要只使用其中一种】查询类别。
		MyBatis提供了<choose>元素支持此类型的SQL预处理。
		如果没有选择查询类别，则查询开始时间在今天之后的课程，代码如下：
		注意:mysql中now()是当前时间 oracle需要使用sysdate
		<select id="searchCourses" parameterType="map" resultMap="CourseResult">
			SELECT * FROM COURSES
			<choose>
				<when test="searchBy == 'Tutor'">
					WHERE TUTOR_ID= #{tutorId}
				</when>
				<when test="searchBy == 'CourseName'">
					WHERE name like #{courseName}
				</when>
				<otherwise>
					WHERE start_date >= sysdate
				</otherwise>
			</choose>
		</select>


			map.put("searchBy", "Tutor");
			map.put("tutorId", 1);
			//map.put("searchBy", "CourseName");
			//map.put("courseName", "%java%");
		MyBatis计算<choose>测试条件的值，且使用第一个值为TRUE的子句。如果没有条件为 true，则使用<otherwise>内的子句。
		相当于我们常用的java代码中的这个例子:
		if(){
			..
		}
		else if(){
			..
		}
		else{
			..
		}


		3.6.3 Where 条件
		有时候，所有的查询条件应该是可选的。在需要使用至少一种查询条件的情况下(条件数量不确定的情况下)，我们应该使用WHERE子句。并且如果有多个条件，我们需要在条件中添加AND或OR。
		MyBatis提供了<where>元素支持这种类型的动态SQL语句。
		在我们查询课程界面，我们假设所有的查询条件是可选的。进而，当需要提供一个或多个查询条件时，应该改使用WHERE子句。
		<select id="searchCourses" parameterType="map" resultMap="CourseResult">
			SELECT * FROM COURSES
			<where>
				<if test="tutorId != null ">
					TUTOR_ID= #{tutorId}
				</if>
				<if test="courseName != null">
				   name like #{courseName}
				</if>
				<if test="startDate != null">
					AND start_date >= #{startDate}
				</if>
				<if test="endDate != null">
					AND end_date <![CDATA[ <= ]]> #{endDate}
				</if>
			</where>
		</select>

			map.put("tutorId", 1);
			map.put("courseName", "%java%");
			map.put("startDate", new SimpleDateFormat("yyyy-mm-dd").parse("2012-10-10"));
			map.put("endDate", new Date());

		<where>元素只有在其内部标签有返回内容时才会在动态语句上插入WHERE条件语句。并且，如果WHERE子句以AND或者OR打头，则打头的AND或OR将会被移除。例如:如果参数tutorId的值为null，并且courseName参数值不为null，则<where>标签会将AND name like #{courseName}中的AND移除掉，生成的SQL WHERE子句为：
		where name like #{courseName}


		3.6.4 <trim>条件
		<trim>元素和<where>元素类似，但是<trim>提供了在添加前缀/后缀或者移除前缀/后缀方面提供更大的灵活性。
		<select id="searchCourses" parameterType="map" resultMap="CourseResult">
			SELECT * FROM COURSES
			<trim prefix="WHERE" suffixOverrides="or | and">
				<if test=" tutorId != null ">
					TUTOR_ID= #{tutorId} and
				</if>
				<if test="courseName != null">
					name like #{courseName} and
				</if>
			</trim>
		</select>

		prefix表示有一个if成立则插入where语句
		suffix表示后缀,和prefix相反

		suffixOverrides="and"表示如果最后生成的sql语句多一个and,则自动去掉.
		prefixOverrides的意思是处理前缀,和suffixOverrides相反

			map.put("tutorId", 1);
			map.put("courseName", "%Java%");


		这里如果任意一个<if>条件为true，<trim>元素会插入WHERE,并且移除紧跟WHERE后面的AND

		<select id="searchCourses" parameterType="map" resultMap="CourseResult">
			SELECT * FROM COURSES
			<trim prefix="WHERE" suffixOverrides="or | and|test" prefixOverrides="and" suffix="or 1=1">
				<if test=" tutorId != null ">
					and TUTOR_ID= #{tutorId} and
				</if>
				<if test="courseName != null">
					name like #{courseName} and
				</if>
			</trim>
		</select>

		3.6.5 foreach 循环
		另外一个强大的动态SQL语句构造标签即是<foreach>。它可以迭代遍历一个数组或者列表，构造AND/OR条件或一个IN子句。
		假设我们想找到tutor_id为 1，3，6的讲师所教授的课程，我们可以传递一个tutor_id组成的列表给映射语句，然后通过<foreach>遍历此列表构造动态SQL。
		<select id="searchCourses" parameterType="map" resultMap="CourseResult">
			SELECT * FROM COURSES
			<if test="tutorIds != null">
				<where>
					<foreach item="tutorId" collection="tutorIds">
						OR tutor_id=#{tutorId}
					</foreach>
				</where>
			</if>
		</select>

		代码:
		public interface DynamicSqlMapper{
			List<Course> searchCoursesByTutors(Map<String,Object> map);
		}
		public void searchCoursesByTutors(){
			Map<String,Object> map = new HashMap<String,Object>();
			List<Integer> tutorIds = new ArrayList<Integer>();
			tutorIds.add(1);
			tutorIds.add(3);
			tutorIds.add(6);
			map.put("tutorIds", tutorIds);
			DynamicSqlMapper mapper =
				sqlSession.getMapper(DynamicSqlMapper.class);
			List<Course> courses = mapper.searchCoursesByTutors(map);
			for (Course course : courses){
				System.out.println(course);
			}
		}

		怎样使用<foreach>生成IN子句：
		<select id="searchCourses" parameterType="map" resultMap="CourseResult">
			SELECT * FROM COURSES
			<if test="tutorIds != null">
				<where>
					tutor_id IN
					<foreach item="tempValue" collection="tutorIds" open="(" separator="," close=")">
						#{tempValue}
					</foreach>
				</where>
			</if>
		</select>

		<!-- <select id="searchCourses" parameterType="map" resultMap="CourseResult">
			SELECT * FROM COURSES
			<if test="tutorIds != null">
				<where>
					tutor_id IN
					<trim prefix="(" suffixOverrides="," suffix=")">
						<foreach item="tutorId" collection="tutorIds">
							#{tutorId},
						</foreach>
					</trim>
				</where>
			</if>
		</select> -->

		3.6.6 set 条件
		<set>元素和<where>元素类似，如果其内部条件判断有任何内容返回时，他会插入SET SQL 片段。

			<update id="updateCourse" parameterType="Course">
				update courses
				<set>
				<if test="name != null">name=#{name},</if>
				<if test="description != null">description=#{description},</if>
				<if test="startDate != null">start_date=#{startDate},</if>
				<if test="endDate != null">end_date=#{endDate},</if>
				</set>
				where course_id=#{courseId}
			</update>

			void updateCourse(Course course);

			Course course = new Course();
			course.setCourseId(3);
			course.setName("MyBatis");
			course.setDescription("MyBatis");
			mapper.updateCourse(course);
			session.commit();

		这里，如果<if>条件返回了任何文本内容，<set>将会插入set关键字和其文本内容，并且会剔除将末尾的“，”。在上述的例子中，如果phone!=null,<set>将会让会移除phone=#{phone}后的逗号“,”，生成set phone=#{phone}



四 mybatis的一些特殊功能 special

	除了简化数据库编程外，MyBatis还提供了各种功能，这些对实现一些常用任务非常有用，比如按页加载表数据，存取CLOB/BLOB类型的数据，处理枚举类型值，等等。

	public void insertUser(User user);
	public User findUserById_test(Integer id);
	public void insertUserPic(UserPic userPic);
	public UserPic getUserPicById(Integer id);
	public List<User> findAllUsers();
	public List<User> findAllUsers(RowBounds rowBounds);
	public User findUserById(Integer id);

	4.1 处理枚举类型
		MyBatis支持持久化enum类型属性。假设t_user表中有一列gender（性别）类型为 varchar2(10)，存储 MALE 或者 FEMALE 两种值。并且，Student对象有一个enum类型的gender 属性，如下所示：

		public enum Gender {
			MALE,FEMALE
		}

		默认情况下MyBatis使用EnumTypeHandler来处理enum类型的Java属性，并且将其存储为 enum值的名称。你不需要为此做任何额外的配置。你可以可以向使用基本数据类型属性一样使用enum类型属性，如下：
		drop table t_user;
		create table t_user(
		  id number primary key,
		  name varchar2(50),
		  gender varchar2(10)
		);

		public class User{
			private Integer id;
			private String name;
			private Gender gender;

			//setters and getters
		}


		<insert id="insertUser" parameterType="User">
			<selectKey keyProperty="id" resultType="int" order="BEFORE">
				select my_seq.nextval from dual
			</selectKey>
			insert into t_user(id,name,gender)
			values(#{id},#{name},#{gender})
		</insert>

		User user = new User("zs",Gender.MALE);
		mapper.insertUser(user);

		当你执行insertStudent语句的时候MyBatis会取Gender枚举（FEMALE/MALE）的名称，然后将其存储到GENDER列中。如果你希望存储原enum的顺序位置(0/1)，而不是enum名，你需要明确地配置它
		如果你想存储FEMALE为0，MALE为1到gender列中，你需要在mybatis-config.xml文件中配置EnumOrdinalTypeHandler:
		<typeHandler handlers="org.apache.ibatis.type.EnumOrdinalTypeHandler" javaType="com.briup.special.Gender"/>

		注意:使用顺序位置为值存储到数据库时要当心。顺序值是根据enum中的声明顺序赋值的。如果你改变了Gender里面对象的声明顺序，则数据库存储的数据和此顺序值就不匹配了。
		查找:
	<select id="findUserById_test" parameterType="int" resultType="User">
		select id,name,gender
		from t_user
		where id=#{id}
	</select>
	注意查找时采用的类型处理器与存储时应一致

	4.2 处理CLOB/BLOB类型数据
		BLOB和CLOB都是大字段类型，BLOB是按二进制来存储的，而CLOB是可以直接存储文字的。通常像图片、文件、音乐等信息就用BLOB字段来存储，先将文件转为二进制再存储进去。而像文章或者是较长的文字，就用CLOB存储.

		BLOB和CLOB在不同的数据库中对应的类型也不一样:
			MySQL 中：clob对应text/longtext，blob对应blob
			Oracle中：clob对应clob，blob对应blob

		MyBatis提供了内建的对CLOB/BLOB类型列的映射处理支持。

		drop table user_pics;
		create table user_pics(
			id number primary key,
			name varchar2(50) ,
			pic blob,
			bio clob
		);

		这里，照片可以是PNG,JPG或其他格式的。简介信息可以是学生的漫长的人生经历。默认情况下，My Batis将CLOB类型的列映射到java.lang.String类型上、而把BLOB列映射到byte[]类型上。
		package com.briup.special;

		public class UserPic{
			private int id;
			private String name;
			private byte[] pic;
			private String bio;
			//setters & getters
		}

		<insert id="insertUserPic" parameterType="UserPic">
			<selectKey keyProperty="id" resultType="int" order="BEFORE">
				select my_seq.nextval from dual
			</selectKey>
			insert into user_pics(id,name, pic,bio)
			values(#{id},#{name},#{pic},#{bio})
		</insert>
		<select id="getUserPicById" parameterType="int" resultType="UserPic">
			select * from user_pics where id=#{id}
		</select>

		java代码:
		@Test
		public void test_insertUserPic(){
			byte[] pic = null;
			try {
				//读取用户头像图片
				File file = new File("src/com/briup/special/test.png");
				InputStream is = new FileInputStream(file);
				pic = new byte[is.available()];
				is.read(pic);
				is.close();
			} catch (Exception e){
				e.printStackTrace();
			}
			String name = "tom";
			String bio = "可以是很长的字符串";
			//准备好要插入到数据库中的数据并封装成对象
			UserPic userPic = new UserPic(name, pic , bio);

			SqlSession session = null;
			try{
				session = MyBatisSqlSessionFactory.openSession();
				SpecialMapper mapper = session.getMapper(SpecialMapper.class);
				mapper.insertUserPic(userPic);
				session.commit();
			}catch (Exception e) {
				e.printStackTrace();
				session.rollback();
			}finally {
				if(session!=null)session.close();
			}
		}

		下面的getUserPic()方法展示了怎样将CLOB类型数据读取到String类型，BLOB类型数据读取成byte[]属性：

		@Test
		public void test_getUserPicById(){

			SqlSession session = null;
			try {
				session = MyBatisSqlSessionFactory.openSession();

				SpecialMapper mapper = session.getMapper(SpecialMapper.class);

				UserPic userPic = mapper.getUserPicById(24);

				System.out.println(userPic.getId());
				System.out.println(userPic.getName());
				System.out.println(userPic.getBio());
				System.out.println(userPic.getPic());
				System.out.println(userPic.getPic().length);

			} catch (Exception e) {
				e.printStackTrace();
			}finally {
				if(session!=null)session.close();
			}
		}


	4.3 传入多个输入参数
		MyBatis中的映射语句有一个parameterType属性来制定输入参数的类型。如果我们想给映射语句传入多个参数的话，我们可以将所有的输入参数放到HashMap中，将HashMap传递给映射语句。同时MyBatis还提供了另外一种传递多个输入参数给映射语句的方法。假设我们想通过给定的name和email信息查找学生信息，定义查询接口如下：
		对于映射器中的方法，MyBatis默认从左到右给方法的参数命名为param1、param2…，依次类推。

		public interface StudentMapper{
			List<Student> findAllStudentsByNameEmail(String name, String email);
		}
		MyBatis支持将多个输入参数传递给映射语句，并以#{param}的语法形式引用它们：
		<select id="findAllStudentsByNameEmail" resultMap="StudentResult">
			select stud_id, name,email, phone from Students
			where
			name=#{param1}
			and
			email=#{param2}
		</select>
		这里#{param1}引用第一个参数name，而#{param2}引用了第二个参数email。

		代码中调用:
		Student Mapper student Mapper = sql Session.get Mapper(StudentMapper.class);
		student Mapper.findAllStudentsByNameEmail(name, email);


	4.4 多行结果集映射成Map
		可以使用之前我们介绍到的接口的方式来实现(默认把列名作为key,列中的值作为value)。
		如果有一些特殊的情况,比如需要使用id值作为key,把一行数据封装成的对象作为value放到map中的话,需要使用下面的方式:

		<select id="findAllUsers" resultType="User">
			select id,name,gender from t_user
		</select>

		Map<Integer, User> map = session.selectMap("com.briup.mappers.SpecialMapper.findAllUsers","id");
		for(Integer key:map.keySet()){
			System.out.println(key+" : "+map.get(key));
		}
		注意:需要注意gender列的值都是数字还是都是字符串(需要一致)

		这里map将会将id作为key值，而每行数据封装成的User对象作为value值。

	4.5 使用RowBounds对结果集进行分页
		有时候，我们会需要跟海量的数据打交道，比如一个有数百万条数据级别的表。由于计算机内存的现实我们不可能一次性加载这么多数据，我们可以获取到数据的一部分。特别是在Web应用程序中，分页机制被用来以一页一页的形式展示海量的数据。
		MyBatis可以使用RowBounds逐页加载表数据。RowBounds对象可以使用offset和limit参数来构建。参数offset表示开始位置，而limit表示要取的记录的数目

		<select id="findAllUsers" resultType="User">
			select id,name,gender from t_user
		</select>

		public List<User> findAllUsers(RowBounds rowBounds);

		然后，你可以加载第一页数据（前5条）：
		int offset = 0;
		int limit = 5;
		RowBounds rowBounds = new RowBounds(offset, limit);
		List<Student> = studentMapper.getStudents(rowBounds);
		若要展示第二页，使用offset=5,limit=5

		但是其实Mybatis的分页是基于内存的分页（查出所有记录再按偏移量和limit取结果），在大数据量的情况下这样的分页效率会很低。

		oracle使用rownum也可以完成分页:
		rownum 等于1  =1
		rownum 大于0  >0
		rownum 小于任何数  <n
		例如:把sql语句查询结果当做一张表再查询
		select *
		from (
			select rownum as rowno, t.*
			from t_user t
			where rownum <= 10
		) temp
		where temp.rowno >= 5;

		//order by 写到sql字句最后，最后执行
		select *
		from (
			select rownum as rowno, t.*
			from t_user t
			where rownum <= 7
			order by id
		) temp
		where temp.rowno >= 6;

		select id,name,gender
			from(select rownum rn,id,name,gender
			from(
				select id,name,gender
				from t_user
				order by id
				)
			)
		where rn<=7 and rn>=6

		select id,name,gender
			from(select rownum rn,id,name,gender
			from(
				select id,name,gender
				from t_user
				order by id
				)
			where rownum<=7)
		where rn>=6


		select *
		from (
			select rownum as rowno, t.*
			from t_user t
			where rownum <= 8
			order by id
		) temp
		where temp.rowno >= 6;

		select * from t_user;
		select * from t_user order by id;
		select * from t_user where rownum <=8 order by id;//先截取后排序
		select * from (select rownum rowno,t.* from (select * from t_user order by id)t)
			where rowno>=6 and  rowno<=8;
		select * from (select rownum rowno,t.* from (select * from t_user order by id)t
			where rownum<=9) where rowno>=6;

	4.6 使用ResultHandler自定义结果集ResultSet处理
		MyBatis在将查询结果集映射到java对象方面提供了很大的选择性。但是，有时候我们会遇到由于特定的目的，需要我们自己处理SQL查询结果的情况。MyBatis提供了ResultHandler接口,可以让我们以任何自己喜欢的方式处理结果集ResultSet。
		例如:我们要把t_user表中所有数据的id和name查询出来,并且把id值作为key,把name值作为value封装到Map集合中

		注意:sqlSession.selectMap()则可以返回以给定列为key，记录对象为value的map。但是不能将其配置成使用其中一个属性作为key，而另外的属性作为 value。但是mybatis在之后的版本中可能会完成这个功能


		对于sqlSession.select()方法，我们可以传递给它一个ResultHandler接口的实现，它会被调用来处理ResultSet的每一条记录,而且完成我们上面的需求:

		@Test
		public void test_ResultHandler(){
			final Map<Integer,String> map = new HashMap<Integer, String>();
			SqlSession session = null;
			try {
				session = MyBatisSqlSessionFactory.openSession();

				session.select("com.briup.mappers.SpecialMapper.findAllUsers", new ResultHandler<User>() {

					@Override
					public void handleResult(ResultContext<? extends User> resultContext) {
						User user = resultContext.getResultObject();
						map.put(user.getId(), user.getName());
					}
				});

				for(Integer key:map.keySet()){
					System.out.println(key+" : "+map.get(key));
				}
			} catch (Exception e) {
				e.printStackTrace();
			}finally {
				if(session!=null)session.close();
			}
		}

		在上述的代码中，我们提供了匿名内部类对ResultHandler接口的实现，在handleResult()方法中，我们使用context.getResultObject()获取当前的result对象，即User对象,并对查询返回的每一行都会调用handleResult()方法，从而我们从User对象中取出id和name的值，将其放到map中。


	4.7 缓存
		将从数据库中加载的数据缓存到内存中，是很多应用程序为了提高性能而采取的一贯做法。默认情况下，mybatis会启用一级缓存；即，如果你使用同一个session对象调用了相同的SELECT语句，则直接会从缓存中返回结果，而不是再查询一次数据库。
		注意:session调用commit或close方法后,这个session中的一级缓存就会被清空

		例如: 根据日志输出可以看出,下面代码只会发出一条sql查询语句
		<select id="findUserById" resultType="User">
			select id,name,gender
			from t_user
			where id=#{id}
		</select>

		@Test
		public void test_cache1(){
			SqlSession session = null;
			try {
				session = MyBatisSqlSessionFactory.openSession();

				SpecialMapper mapper = session.getMapper(SpecialMapper.class);

				User user1 = mapper.findUserById(21);
				System.out.println(user1);

	//			session.commit();

				User user2 = mapper.findUserById(21);
				System.out.println(user2);

			} catch (Exception e) {
				e.printStackTrace();
			}finally {
				if(session!=null)session.close();
			}
		}

		二级缓存: 在不同的session对象之间可以共享缓存的数据
		1.mybatis-config.xml文件中保证<setting name="cacheEnabled" value="true"/>设置中是缓存功能是开启的,默认就是开启的true
		2.在需要二级缓存的xml映射文件中,手动开启缓存功能,在根元素中加入一个标签即可:<cache/>
		3.一个session查询完数据之后,需要调用commit或者close方法后,这个数据才会进入到二级缓存中,然后其他session就可以共享到这个缓存数据了

		注意:默认情况下,被二级缓存保存的对象需要实现序列化接口,可以通过cache标签的readOnly属性进行设置

		例如:
		mybatis-config.xml:
		<settings>
			<setting name="cacheEnabled" value="true"/>
		</settings>

		xml映射文件:
		<mapper namespace="com.briup.mappers.SpecialMapper">
			<cache/>
			<select> ..</select>
			<select> ..</select>
			<select> ..</select>
		</mapper>

		测试代码:
		@Test
		public void test_cache2(){
			SqlSession session1 = null;
			SqlSession session2 = null;
			try {
				session1 = MyBatisSqlSessionFactory.openSession();
				session2 = MyBatisSqlSessionFactory.openSession();

				SpecialMapper mapper1 = session1.getMapper(SpecialMapper.class);
				SpecialMapper mapper2 = session2.getMapper(SpecialMapper.class);

				User user1 = mapper1.findUserById(21);
				System.out.println(user1);
				session1.commit();

				User user2 = mapper2.findUserById(21);
				System.out.println(user2);
				session2.commit();
			} catch (Exception e) {
				e.printStackTrace();
			}finally {
				if(session1!=null)session1.close();
				if(session2!=null)session2.close();
			}
		}

		二级缓存补充说明
		　　1. 映射语句文件中的所有select语句将会被缓存
		　　2. 映射语句文件中的所有insert，update和delete语句会刷新缓存
		　　3. 缓存会使用Least Recently Used（LRU，最近最少使用的）算法来收回。
		　　4. 缓存会根据指定的时间间隔来刷新。
		　　5. 缓存会存储1024个对象

		cache标签常用属性：
		<cache
		eviction="FIFO"  <!--回收策略为先进先出-->
		flushInterval="60000" <!--自动刷新时间60s-->
		size="512" <!--最多缓存512个引用对象-->
		readOnly="true"/> <!--true表示对象不能被写出去,即不可以被序列化,false表示可以写出去,即可以被序列化,默认值是false-->


五 MyBatis中的注解
	之前我们都是在映射器MapperXML配置文件中配置映射语句的。除此之外MyBatis也支持使用注解来配置映射语句。当我们使用基于注解的映射器接口时，我们不再需要在XML配置文件中配置了。如果你愿意，你也可以同时使用基于XML和基于注解的映射语句。但是要注意命名空间不能重复

	使用Person进行测试
	drop table person;
	create table person(
		pid number primary key,
		name varchar2(15),
		age number
	);
	public class Person{
		private Integer id;
		private String name;
		private Integer age;

		get/set
	}

	public void insertPerson(Person person);
	public void insertPersonAutoId(Person person);
	public void updatePerson(Person person);
	public void deletePersonById(Integer id);
	public Person findPersonById(Integer id);
	public List<Person> findAllPerson();
	public List<Person> findAllPerson_ResultMap();
	public List<Person> findAllPerson_ResultMap_XML();

	public Address findAddressById(Integer addrId);
	public com.briup.bean.Student findStudentByIdWithAddress(Integer id);
	public com.briup.bean.Student findStudentByIdWithAddress_resultMap(Integer id);

	public List<Course> findCoursesByTutorId(Integer tutor_id);
	public Tutor findTutorById(int tutorId);
	public Tutor findTutorById_resultMap(int tutorId);

	5.1 在映射器Mapper接口上使用注解
		MyBatis对于大部分的基于XML的映射器元素（包括<select>,<update>）提供了对应的基于注解的配置项。然而在某些情况下，基于注解配置还不能支持基于XML的一些元素。

	5.2 映射语句
		MyBatis提供了多种注解来支持不同类型的语句如:SELECT,INSERT,UPDATE,DELETE。

		5.2.1 @Insert
		我们可以使用 @Insert注解来定义一个INSERT映射语句：

		package com.briup.mappers;
		public interface StudentMapper{

			@Insert("insert into students(stud_id,name,email,addr_id, phone) values(#{studId},#{name},#{email},#{address.addrId},#{phone})")
			int insertStudent(Student student);

		}

		AnnotationMapper mapper = session.getMapper(AnnotationMapper.class);
		Person person = new Person(1,"tom",20);
		mapper.insertPerson(person);

		自动生成主键

		可以使用 @Options注解的userGeneratedKeys和keyProperty属性让数据库产生 auto_increment（自增长）列的值，然后将生成的值设置到输入参数对象的属性中。

		@Insert("insert into students(name,email,addr_id, phone)
				values(#{name},#{email},#{address.addr Id},#{phone})")
		@Options(useGeneratedKeys = true, keyProperty = "studId")
		int insertStudent(Student student);

		这里STUD_ID列值将会通过MySQL数据库自动生成。并且生成的值将会被设置到student对象的studId属性中。
		StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);
		mapper.insertStudent(student);
		int studentId = student.getStudId();

		有一些数据库如Oracle，并不支持AUTO_INCREMENT列属性，它使用序列（SEQUENCE）来产生主键的值。
		我们可以使用 @SelectKey注解来为任意SQL语句来指定主键值，作为主键列的值。假设我们有一个名为STUD_ID_SEQ的序列来生成STUD_ID主键值。

		@Insert("insert into students(stud_id,name,email,addr_id,phone) values(#{studId},#{name},#{email},#{address.addrId},#{phone})")
		@SelectKey(statement="select my_seq.nextval from dual",
		keyProperty="studId", resultType=int.class, before=true)
		int insertStudent(Student student);

		AnnotationMapper mapper = session.getMapper(AnnotationMapper.class);
		Person person = new Person("tom2",30);
		mapper.insertPersonAutoId(person);

		这里我们使用了 @SelectKey来生成主键值，并且存储到了student对象的studId属性上。由于我们设置了before=true,该语句将会在执行INSERT语句之前执行.





		5.2.2 @Update
		我们可以使用 @Update注解来定义一个UPDATE映射语句，如下所示：
		@Update("update students set name=#{name}, email=#{email},
		phone=#{phone} where stud_id=#{studId}")
		int updateStudent(Student student);


		StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);
		int noOfRowsUpdated = mapper.updateStudent(student);



		5.2.3 @Delete
		我们可以使用 @Delete注解来定义一个DELETE映射语句，如下所示：
		@Delete("delete from students where stud_id=#{studId}")
		int deleteStudent(int studId);


		5.2.4 @Select
		我们可以使用 @Select注解来定义一个SELECT映射语句。

		package com.briup.mappers;
		public interface StudentMapper{
			@Select("select stud_id as studid, name, email, phone from
					students where stud_id=#{studId}")
			Student findStudentById(Integer studId);
		}
		为了将列名和对象中属性名匹配，我们为stud_id起了一个studId的别名。如果返回了多行结果，将抛出TooManyResultsException异常。


	5.3 结果映射
		我们可以将查询结果通过别名或者是 @Results注解与JavaBean属性映射起来。

		package com.briup.mappers;
		public interface StudentMapper{
			@Select("select * from students")
			@Results(
			{
				@Result(id = true, column = "stud_id", property = "studId"),
				@Result(column = "name", property = "name"),
				@Result(column = "email", property = "email"),
				@Result(column = "addr_id", property = "address.addrId")
			})
			List<Student> findAllStudents();
		}

		注意:
		@Results注解和映射器XML配置文件元素<resultMap> 对应。然而，My Batis3.2.2不能为 @Results注解赋予一个ID。所以，不像<resultMap>元素，我们不应在不同的映射语句中重用 @Results声明。这意味着即使 @Results注解完全相同，我们也需要(在不同的映射接口中)重复 @Results声明。


		例如，看下面的 findStudentById()和 findAllStudents()方法：

		@Select("select * from students where stud_id=#{studId}")
		@Results(
		{
			@Result(id = true, column = "stud_id", property = "studId"),
			@Result(column = "name", property = "name"),
			@Result(column = "email", property = "email"),
			@Result(column = "addr_id", property = "address.addrId")
		})
		Student findStudentById(int studId);

		@Select("select * from students")
		@Results(
		{
			@Result(id = true, column = "stud_id", property = "studId"),
			@Result(column = "name", property = "name"),
			@Result(column = "email", property = "email"),
			@Result(column = "addr_id", property = "address.addrId")
		})
		List<Student> findAllStudents();


		这里两个语句的 @Results配置完全相同，但是必须得重复它。这里有一个解决方法。我们可以创建一个映射器Mapper配置文件，然后配置<resultMap>元素，然后使用 @ResultMap注解引用此<resultMap>。 在StudentMapper.xml中定义一个ID为StudentResult的<resultMap>。命名空间不能重复

		xml配置:

		<mapper namespace="com.briup.mappers.StudentMapper2">
		  <resultMap type="Student" id="StudentResult">
			<id property="studId" column="stud_id" />
			<result property="name" column="name" />
			<result property="email" column="email" />
			<result property="phone" column="phone" />
		  </resultMap>
		</mapper>

		在StudentMapper.java中,使用 @Result Map引用名为StudentResult的resultMap:

		public interface StudentMapper{
			@Select("select * from students where stud_id=#{studId}")
			@ResultMap("com.briup.mappers.StudentMapper.StudentResult")
			Student findStudentById(int studId);

			@Select("select * from students")
			@ResultMap("com.briup.mappers.StudentMapper2.StudentResult")
			List<Student> findAllStudents();
		}



	5.4 一对一映射
		MyBatis提供了 @One注解来使用嵌套select语句（Nested-Select）加载一对一关联查询数据。让我们看看怎样使用 @One注解获取学生及其地址信息

		public interface StudentMapper{
			@Select("select addr_id as addrId, street, city, state, zip, country from addresses where addr_id=#{id}")
			Address findAddressById(int id);

			@Select("select * from students where stud_id=#{studId} ")
			@Results(
			{
				@Result(id = true, column = "stud_id", property = "studId"),
				@Result(column = "name", property = "name"),
				@Result(column = "email", property = "email"),
				@Result(property = "address", column = "addr_id",
				one = @One(select = "com.briup.mappers.Student Mapper.findAddressById"))
			})
			Student selectStudentWithAddress(int studId);
		}

		这里我们使用了 @One注解的select属性来指定一个使用了完全限定名的方法上，该方法会返回一个Address对象。使用column=”addr_id”,则STUEDNTS表中列addr_id的值将会作为输入参数传递给find Address By Id()方法。如果 @One SELECT查询返回了多行结果，则会抛出TooManyResultsException异常。

		int studId = 1;
		StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);
		Student student = studentMapper.selectStudentWithAddress(studId);
		System.out.println("Student :"+student);
		System.out.println("Address :"+student.getAddress());

		我们可以通过基于XML的映射器配置，使用嵌套结果ResultMap来加载一对一关联的查询。而MyBatis3.2.2 版本，并没有对应的注解支持。但是我们可以在映射器Mapper配置文件中配置<resultMap>并且使用 @ResultMap注解来引用它。
		在StudentMapper.xml中配置<resultMap>，如下所示：
		<mapper namespace="com.briup.mappers.StudentMapper">
		  <resultMap type="Address" id="AddressResult">
			<id property="addrId" column="addr_id" />
			<result property="street" column="street" />
			<result property="city" column="city" />
			<result property="state" column="state" />
			<result property="zip" column="zip" />
			<result property="country" column="country" />
		  </resultMap>
		  <resultMap type="Student" id="StudentWithAddressResult">
			<id property="studId" column="stud_id" />
			<result property="name" column="name" />
			<result property="email" column="email" />
			<association property="address" resultMap="AddressResult" />
		  </resultMap>
		</mapper>

		public interface StudentMapper{
			@Select("select stud_id, name, email, a.addr_id, street, city, state, zip, country" + " FROM students s left outer join addresses a on s.addr_id=a.addr_id" + " where stud_id=#{studId} ")
			@ResultMap("com.briup.mappers.StudentMapper.StudentWithAddressResult")
			Student selectStudentWithAddress(int id);
		}






	5.5 一对多映射
	MyBatis提供了 @Many注解，用来使用嵌套Select语句加载一对多关联查询。现在让我们看一下如何使用 @Many注解获取一个讲师及其教授课程列表信息：

	public interface TutorMapper{
		@Select("select addr_id as addrId, street, city, state, zip,
				country from addresses where addr_id=#{id}")
		Address findAddressById(int id);

		@Select("select * from courses where tutor_id=#{tutorId}")
		@Results(
		{
			@Result(id = true, column = "course_id", property = "courseId"),
			@Result(column = "name", property = "name"),
			@Result(column = "description", property = "description"),
			@Result(column = "start_date" property = "startDate"),
			@Result(column = "end_date" property = "endDate")
		})
		List<Course> findCoursesByTutorId(int tutorId);

		@Select("SELECT tutor_id, name as tutor_name, email, addr_id
				FROM tutors where tutor_id=#{tutorId}")
		@Results(
		{
			@Result(id = true, column = "tutor_id", property = "tutorId"),
			@Result(column = "tutor_name", property = "name"),
			@Result(column = "email", property = "email"),
			@Result(property = "address", column = "addr_id",
			one = @One(select = "com.briup.mappers.Tutor Mapper.findAddressById")),
			@Result(property = "courses", column = "tutor_id",
			many = @Many(select = "com.briup.mappers.Tutor Mapper.findCoursesByTutorId"))
		})
		Tutor findTutorById(int tutorId);
	}

	这里我们使用了 @Many注解的select属性来指向一个完全限定名称的方法，该方法将返回一个 List<Course>对象。使用column=”tutor_id”，TUTORS表中的tutor_id列值将会作为输入参数传递给find Courses By Tutor Id()方法。
	之前我们使用过嵌套结果ResultMap来加载一对多关联的查询。而MyBatis3.2.2版本，并没有对应的注解支持。但是我们可以在映射器Mapper配置文件中配置<result Map>并且使用 @ResultMap注解来引用它。

	在TutorMapper.xml中配置<resultMap>,如下所示：
	<mapper namespace="com.briup.mappers.Tutor Mapper">
	  <resultMap type="Address" id="AddressResult">
		<id property="addrId" column="addr_id" />
		<result property="street" column="street" />
		<result property="city" column="city" />
		<result property="state" column="state" />
		<result property="zip" column="zip" />
		<result property="country" column="country" />
	  </resultMap>
	  <resultMap type="Course" id="CourseResult">
		<id column="course_id" property="course Id" />
		<result column="name" property="name" />
		<result column="description" property="description" />
		<result column="start_date" property="startDate" />
		<result column="end_date" property="endDate" />
	  </resultMap>
	  <resultMap type="Tutor" id="TutorResult">
		<id column="tutor_id" property="tutorId" />
		<result column="tutor_name" property="name" />
		<result column="email" property="email" />
		<association property="address" result Map="AddressResult" />
		<collection property="courses" result Map="CourseResult" />
	  </resultMap>
	</mapper>


	public interface TutorMapper{
		@Select("select t.tutor_id, t.name as tutor_name,email,a.addr_id, street, city, state, zip, country, course_id, c.name,description, start_date, end_date  from tutors t left outer join addresses a on t.addr_id=a.addr_id left outer join courses c on t.tutor_id=c.tutor_id where t.tutor_id=#{tutorId}")
		@Result Map("com.briup.mappers.TutorMapper.TutorResult")
		Tutor selectTutorById(int tutorId);
	}